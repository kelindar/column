# github.com/kelindar/column
.\collection.go:117:22: (*Collection).Insert.func1 capturing by value: obj (addr=false assign=false width=8)
.\collection.go:117:3: (*Collection).Insert.func1 capturing by ref: index (addr=true assign=true width=4)
.\collection.go:127:29: (*Collection).InsertWithTTL.func1 capturing by value: obj (addr=false assign=false width=8)
.\collection.go:127:34: (*Collection).InsertWithTTL.func1 capturing by value: ttl (addr=false assign=false width=8)
.\collection.go:127:3: (*Collection).InsertWithTTL.func1 capturing by ref: index (addr=true assign=true width=4)
.\collection.go:137:35: (*Collection).UpdateAt.func1 capturing by value: columnName (addr=false assign=false width=16)
.\collection.go:138:17: (*Collection).UpdateAt.func1 capturing by value: idx (addr=false assign=false width=4)
.\collection.go:139:18: (*Collection).UpdateAt.func1 capturing by value: value (addr=false assign=false width=16)
.\collection.go:149:26: (*Collection).DeleteAt.func1 capturing by value: idx (addr=false assign=false width=4)
.\collection.go:149:3: (*Collection).DeleteAt.func1 capturing by ref: deleted (addr=true assign=true width=1)
.\collection.go:201:16: (*Collection).CreateIndex.func1 capturing by value: column (addr=false assign=false width=8)
.\collection.go:202:13: (*Collection).CreateIndex.func1 capturing by value: fn (addr=false assign=false width=8)
.\collection.go:284:51: (*Collection).vacuum.func1.1 capturing by value: now (addr=false assign=false width=8)
.\collection.go:287:5: (*Collection).vacuum.func1 capturing by value: now (addr=false assign=false width=8)
.\collection.go:298:6: (*Collection).Replay.func1 capturing by ref: change (addr=true assign=false width=80)
.\column.go:273:27: (*columnAny).FilterString.func1 capturing by value: c (addr=false assign=false width=8)
.\column.go:273:39: (*columnAny).FilterString.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_generate.go:121:27: (*columnnumber).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_generate.go:121:39: (*columnnumber).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_generate.go:129:27: (*columnnumber).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_generate.go:129:39: (*columnnumber).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_generate.go:137:27: (*columnnumber).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_generate.go:137:39: (*columnnumber).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:122:27: (*columnFloat32).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:122:39: (*columnFloat32).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:130:27: (*columnFloat32).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:130:39: (*columnFloat32).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:138:27: (*columnFloat32).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:138:39: (*columnFloat32).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:252:27: (*columnFloat64).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:252:39: (*columnFloat64).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:260:27: (*columnFloat64).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:260:39: (*columnFloat64).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:268:27: (*columnFloat64).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:268:39: (*columnFloat64).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:382:27: (*columnInt).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:382:39: (*columnInt).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:390:27: (*columnInt).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:390:39: (*columnInt).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:398:27: (*columnInt).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:398:39: (*columnInt).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:512:27: (*columnInt16).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:512:39: (*columnInt16).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:520:27: (*columnInt16).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:520:39: (*columnInt16).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:528:27: (*columnInt16).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:528:39: (*columnInt16).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:642:27: (*columnInt32).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:642:39: (*columnInt32).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:650:27: (*columnInt32).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:650:39: (*columnInt32).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:658:27: (*columnInt32).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:658:39: (*columnInt32).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:772:27: (*columnInt64).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:772:39: (*columnInt64).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:780:27: (*columnInt64).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:780:39: (*columnInt64).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:788:27: (*columnInt64).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:788:39: (*columnInt64).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:902:27: (*columnUint).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:902:39: (*columnUint).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:910:27: (*columnUint).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:910:39: (*columnUint).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:918:27: (*columnUint).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:918:39: (*columnUint).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1032:27: (*columnUint16).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1032:39: (*columnUint16).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1040:27: (*columnUint16).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1040:39: (*columnUint16).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1048:27: (*columnUint16).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1048:39: (*columnUint16).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1162:27: (*columnUint32).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1162:39: (*columnUint32).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1170:27: (*columnUint32).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1170:39: (*columnUint32).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1178:27: (*columnUint32).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1178:39: (*columnUint32).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1292:27: (*columnUint64).FilterFloat64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1292:39: (*columnUint64).FilterFloat64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1300:27: (*columnUint64).FilterInt64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1300:39: (*columnUint64).FilterInt64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_numbers.go:1308:27: (*columnUint64).FilterUint64.func1 capturing by value: c (addr=false assign=false width=8)
.\column_numbers.go:1308:39: (*columnUint64).FilterUint64.func1 capturing by value: predicate (addr=false assign=false width=8)
.\column_strings.go:142:23: (*columnEnum).FilterString.func1 capturing by value: c (addr=false assign=false width=8)
.\column_strings.go:143:32: (*columnEnum).FilterString.func1 capturing by ref: cache (addr=true assign=true width=8)
.\column_strings.go:145:19: (*columnEnum).FilterString.func1 capturing by value: predicate (addr=false assign=false width=8)
.\tnx_lock.go:64:29: (*Txn).commitEach.func1 capturing by value: fill (addr=false assign=false width=24)
.\tnx_lock.go:68:3: (*Txn).commitEach.func1 capturing by ref: lock (addr=true assign=false width=8192)
.\tnx_lock.go:69:3: (*Txn).commitEach.func1 capturing by value: f (addr=false assign=false width=8)
.\txn.go:139:16: (*Txn).WithValue.func1.1 capturing by value: c (addr=false assign=false width=8)
.\txn.go:140:13: (*Txn).WithValue.func1.1 capturing by value: predicate (addr=false assign=false width=8)
.\txn.go:143:3: (*Txn).WithValue.func1 capturing by value: c (addr=false assign=false width=8)
.\txn.go:143:3: (*Txn).WithValue.func1 capturing by value: predicate (addr=false assign=false width=8)
.\txn.go:158:3: (*Txn).WithFloat.func1 capturing by value: c (addr=false assign=false width=8)
.\txn.go:158:44: (*Txn).WithFloat.func1 capturing by value: predicate (addr=false assign=false width=8)
.\txn.go:173:3: (*Txn).WithInt.func1 capturing by value: c (addr=false assign=false width=8)
.\txn.go:173:42: (*Txn).WithInt.func1 capturing by value: predicate (addr=false assign=false width=8)
.\txn.go:188:3: (*Txn).WithUint.func1 capturing by value: c (addr=false assign=false width=8)
.\txn.go:188:43: (*Txn).WithUint.func1 capturing by value: predicate (addr=false assign=false width=8)
.\txn.go:203:3: (*Txn).WithString.func1 capturing by value: c (addr=false assign=false width=8)
.\txn.go:203:43: (*Txn).WithString.func1 capturing by value: predicate (addr=false assign=false width=8)
.\txn.go:283:4: (*Txn).Select.func1.1 capturing by value: fn (addr=false assign=false width=8)
.\txn.go:284:10: (*Txn).Select.func1.1 capturing by value: offset (addr=false assign=false width=4)
.\txn.go:285:5: (*Txn).Select.func1.1 capturing by value: txn (addr=false assign=false width=8)
.\txn.go:287:3: (*Txn).Select.func1 capturing by value: fn (addr=false assign=false width=8)
.\txn.go:287:3: (*Txn).Select.func1 capturing by value: txn (addr=false assign=false width=8)
.\txn.go:296:6: (*Txn).DeleteIf.func1 capturing by value: fn (addr=false assign=false width=8)
.\txn.go:296:26: (*Txn).DeleteIf.func1 capturing by value: txn (addr=false assign=false width=8)
.\txn.go:310:3: (*Txn).DeleteAll.func1 capturing by value: txn (addr=false assign=false width=8)
.\txn.go:324:14: (*Txn).Range.func1.1 capturing by value: offset (addr=false assign=false width=4)
.\txn.go:324:4: (*Txn).Range.func1.1 capturing by ref: cur (addr=true assign=true width=40)
.\txn.go:325:4: (*Txn).Range.func1.1 capturing by value: fn (addr=false assign=false width=8)
.\txn.go:326:3: (*Txn).Range.func1 capturing by ref: cur (addr=true assign=true width=40)
.\txn.go:326:3: (*Txn).Range.func1 capturing by value: fn (addr=false assign=false width=8)
.\txn.go:367:3: (*Txn).commit.func1 capturing by ref: typ (addr=true assign=true width=1)
.\txn.go:367:10: (*Txn).commit.func1 capturing by value: txn (addr=false assign=false width=8)
.\txn.go:369:35: (*Txn).commit.func1 capturing by value: max (addr=false assign=false width=4)
.\txn.go:438:17: (*Txn).commitDeletes.func1 capturing by value: at (addr=false assign=false width=8)
.\txn.go:438:21: (*Txn).commitDeletes.func1 capturing by value: deletes (addr=false assign=false width=24)
.\collection.go:342:6: can inline makeColumns with cost 75 as: func(int) columns { data := columns{...}; data.cols.Store(make([]columnEntry, 0, capacity)); return data }
.\collection.go:389:6: cannot inline (*columns).Store: unhandled op RANGE
.\collection.go:392:24: inlining call to atomic.(*Value).Load method(*atomic.Value) func() interface {} { var atomic.vp·3 *atomic.ifaceWords; atomic.vp·3 = <N>; atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)); var atomic.typ·4 unsafe.Pointer; atomic.typ·4 = <N>; atomic.typ·4 = atomic.LoadPointer(&atomic.vp·3.typ); if atomic.typ·4 == nil || uintptr(atomic.typ·4) == uintptr(18446744073709551615) { return nil }; var atomic.data·5 unsafe.Pointer; atomic.data·5 = <N>; atomic.data·5 = atomic.LoadPointer(&atomic.vp·3.data); var atomic.xp·6 *atomic.ifaceWords; atomic.xp·6 = <N>; atomic.xp·6 = (*atomic.ifaceWords)(unsafe.Pointer(&atomic.x)); atomic.xp·6.typ = atomic.typ·4; atomic.xp·6.data = atomic.data·5; return  }
.\column.go:25:6: can inline typeOf with cost 29 as: func(Column) columnType { if ok { typ = typ | typeNumeric }; if ok { typ = typ | typeTextual }; return  }
.\column.go:125:6: can inline columnFor with cost 40 as: func(string, Column) *column { return &column{...} }
.\column.go:127:17: inlining call to typeOf func(Column) columnType { if ok { typ = typ | typeNumeric }; if ok { typ = typ | typeTextual }; return  }
.\collection.go:168:6: cannot inline (*Collection).CreateColumn: function too complex: cost 170 exceeds budget 80
.\collection.go:170:36: inlining call to columnFor func(string, Column) *column { return &column{...} }
.\collection.go:170:36: inlining call to typeOf func(Column) columnType { if ok { typ = typ | typeNumeric }; if ok { typ = typ | typeTextual }; return  }
.\txn.go:332:6: cannot inline (*Txn).reset: unhandled op RANGE
.\txn.go:32:6: cannot inline aquireTxn: function too complex: cost 207 exceeds budget 80
.\txn.go:347:6: can inline (*Txn).rollback with cost 60 as: method(*Txn) func() { txn.reset() }
.\txn.go:43:6: can inline releaseTxn with cost 62 as: func(*Txn) { txns.Put(txn) }
.\tnx_lock.go:58:6: cannot inline (*Txn).commitEach: unhandled op CLOSURE
.\tnx_lock.go:62:18: cannot inline (*Txn).commitEach.func1: function too complex: cost 245 exceeds budget 80
.\tnx_lock.go:68:12: inlining call to smutex.(*SMutex128).Lock method(*smutex.SMutex128) func(uint) { smutex.rw.mu[smutex.shard % uint(128)].RWMutex.Lock() }
.\tnx_lock.go:70:14: inlining call to smutex.(*SMutex128).Unlock method(*smutex.SMutex128) func(uint) { smutex.rw.mu[smutex.shard % uint(128)].RWMutex.Unlock() }
.\collection.go:358:6: cannot inline (*columns).Range: unhandled op RANGE
.\collection.go:359:21: inlining call to atomic.(*Value).Load method(*atomic.Value) func() interface {} { var atomic.vp·3 *atomic.ifaceWords; atomic.vp·3 = <N>; atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)); var atomic.typ·4 unsafe.Pointer; atomic.typ·4 = <N>; atomic.typ·4 = atomic.LoadPointer(&atomic.vp·3.typ); if atomic.typ·4 == nil || uintptr(atomic.typ·4) == uintptr(18446744073709551615) { return nil }; var atomic.data·5 unsafe.Pointer; atomic.data·5 = <N>; atomic.data·5 = atomic.LoadPointer(&atomic.vp·3.data); var atomic.xp·6 *atomic.ifaceWords; atomic.xp·6 = <N>; atomic.xp·6 = (*atomic.ifaceWords)(unsafe.Pointer(&atomic.x)); atomic.xp·6.typ = atomic.typ·4; atomic.xp·6.data = atomic.data·5; return  }
.\column.go:150:6: can inline (*column).Delete with cost 63 as: method(*column) func(int, bitmap.Bitmap) { c.Column.Delete(offset, items) }
.\txn.go:425:6: cannot inline (*Txn).commitDeletes: unhandled op CLOSURE
.\txn.go:437:23: can inline (*Txn).commitDeletes.func1 with cost 68 as: func(*column) { column.Delete(at, deletes) }
.\txn.go:438:16: inlining call to (*column).Delete method(*column) func(int, bitmap.Bitmap) { c.Column.Delete(offset, items) }
.\txn.go:448:6: cannot inline (*Txn).commitInserts: function too complex: cost 106 exceeds budget 80
.\collection.go:378:6: cannot inline (*columns).LoadWithIndex: unhandled op RANGE
.\collection.go:379:21: inlining call to atomic.(*Value).Load method(*atomic.Value) func() interface {} { var atomic.vp·3 *atomic.ifaceWords; atomic.vp·3 = <N>; atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)); var atomic.typ·4 unsafe.Pointer; atomic.typ·4 = <N>; atomic.typ·4 = atomic.LoadPointer(&atomic.vp·3.typ); if atomic.typ·4 == nil || uintptr(atomic.typ·4) == uintptr(18446744073709551615) { return nil }; var atomic.data·5 unsafe.Pointer; atomic.data·5 = <N>; atomic.data·5 = atomic.LoadPointer(&atomic.vp·3.data); var atomic.xp·6 *atomic.ifaceWords; atomic.xp·6 = <N>; atomic.xp·6 = (*atomic.ifaceWords)(unsafe.Pointer(&atomic.x)); atomic.xp·6.typ = atomic.typ·4; atomic.xp·6.data = atomic.data·5; return  }
.\column.go:144:6: cannot inline (*column).Update: function too complex: cost 124 exceeds budget 80
.\txn.go:388:6: cannot inline (*Txn).commitUpdates: unhandled op RANGE
.\txn.go:355:6: cannot inline (*Txn).commit: unhandled op CLOSURE
.\txn.go:358:27: inlining call to bitmap.Bitmap.Max method(bitmap.Bitmap) func() (uint32, bool) { var bitmap.blk·4 uint64; bitmap.blk·4 = <N>; for loop; return uint32(0), bool(false) }
.\txn.go:358:27: inlining call to bits.LeadingZeros64 func(uint64) int { return int(64) - bits.Len64(bits.x) }
.\txn.go:366:17: cannot inline (*Txn).commit.func1: function too complex: cost 192 exceeds budget 80
.\collection.go:247:6: cannot inline (*Collection).Query: function too complex: cost 547 exceeds budget 80
.\collection.go:248:14: inlining call to sync.(*RWMutex).RLock method(*sync.RWMutex) func() { if bool(false) {  }; if atomic.AddInt32(&sync.rw.readerCount, int32(1)) < int32(0) { sync.runtime_SemacquireMutex(&sync.rw.readerSem, bool(false), int(0)) }; if bool(false) {  } }
.\collection.go:250:16: inlining call to sync.(*RWMutex).RUnlock method(*sync.RWMutex) func() { if bool(false) {  }; if sync.r·2 < int32(0) { sync.rw.rUnlockSlow(sync.r·2) }; if bool(false) {  } }
.\collection.go:254:15: inlining call to (*Txn).rollback method(*Txn) func() { txn.reset() }
.\collection.go:255:13: inlining call to releaseTxn func(*Txn) { txns.Put(txn) }
.\collection.go:262:12: inlining call to releaseTxn func(*Txn) { txns.Put(txn) }
.\collection.go:366:6: cannot inline (*columns).Load: unhandled op RANGE
.\collection.go:367:21: inlining call to atomic.(*Value).Load method(*atomic.Value) func() interface {} { var atomic.vp·3 *atomic.ifaceWords; atomic.vp·3 = <N>; atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)); var atomic.typ·4 unsafe.Pointer; atomic.typ·4 = <N>; atomic.typ·4 = atomic.LoadPointer(&atomic.vp·3.typ); if atomic.typ·4 == nil || uintptr(atomic.typ·4) == uintptr(18446744073709551615) { return nil }; var atomic.data·5 unsafe.Pointer; atomic.data·5 = <N>; atomic.data·5 = atomic.LoadPointer(&atomic.vp·3.data); var atomic.xp·6 *atomic.ifaceWords; atomic.xp·6 = <N>; atomic.xp·6 = (*atomic.ifaceWords)(unsafe.Pointer(&atomic.x)); atomic.xp·6.typ = atomic.typ·4; atomic.xp·6.data = atomic.data·5; return  }
.\txn.go:69:6: cannot inline (*Txn).columnAt: unhandled op RANGE
.\txn_cursor.go:13:6: cannot inline (*Txn).cursorFor: unhandled op RANGE
.\tnx_lock.go:21:6: cannot inline (*Txn).rlockEach: function too complex: cost 247 exceeds budget 80
.\txn.go:316:6: cannot inline (*Txn).Range: unhandled op CLOSURE
.\txn.go:322:16: cannot inline (*Txn).Range.func1: unhandled op CLOSURE
.\txn.go:323:15: can inline (*Txn).Range.func1.1 with cost 67 as: func(uint32) { cur.Selector.idx = offset + x; fn(cur) }
.\tnx_lock.go:40:6: cannot inline (*Txn).rlockEachPair: function too complex: cost 259 exceeds budget 80
.\txn.go:91:6: cannot inline (*Txn).With: unhandled op RANGE
.\txn.go:94:43: can inline (*Txn).With.func1 with cost 62 as: func(bitmap.Bitmap, bitmap.Bitmap) { dst.And(src) }
.\column.go:177:6: can inline (*column).Int64 with cost 77 as: method(*column) func(uint32) (int64, bool) { if contains { v, ok = n.LoadInt64(idx) }; return  }
.\txn_cursor.go:145:6: cannot inline (*Cursor).Int: function too complex: cost 88 exceeds budget 80
.\txn_cursor.go:146:27: inlining call to (*column).Int64 method(*column) func(uint32) (int64, bool) { if contains { v, ok = n.LoadInt64(idx) }; return  }
.\txn_cursor.go:165:6: cannot inline (*Cursor).Delete: function too complex: cost 136 exceeds budget 80
.\collection.go:273:6: cannot inline (*Collection).vacuum: unhandled op SELECT
.\collection.go:278:15: inlining call to time.(*Ticker).Stop method(*time.Ticker) func() { time.stopTimer(&time.t.r) }
.\collection.go:281:30: inlining call to time.Time.UnixNano method(time.Time) func() int64 { return time.t.unixSec() * int64(1000000000) + int64(time.t.nsec()) }
.\collection.go:281:30: inlining call to time.(*Time).unixSec method(*time.Time) func() int64 { return time.t.sec() + int64(-62135596800) }
.\collection.go:281:30: inlining call to time.(*Time).sec method(*time.Time) func() int64 { if time.t.wall & uint64(9223372036854775808) != uint64(0) { return int64(59453308800) + int64(time.t.wall << uint(1) >> uint(31)) }; return time.t.ext }
.\collection.go:281:30: inlining call to time.(*Time).nsec method(*time.Time) func() int32 { return int32(time.t.wall & uint64(1073741823)) }
.\collection.go:282:12: cannot inline (*Collection).vacuum.func1: unhandled op CLOSURE
.\collection.go:283:55: cannot inline (*Collection).vacuum.func1.1: function too complex: cost 194 exceeds budget 80
.\collection.go:47:6: cannot inline NewCollection: unhandled op RANGE
.\collection.go:68:54: inlining call to context.Background func() context.Context { return context.Context(context.background) }
.\collection.go:70:22: inlining call to makeColumns func(int) columns { data := columns{...}; data.cols.Store(make([]columnEntry, 0, capacity)); return data }
.\collection.go:93:6: cannot inline (*Collection).findFreeIndex: function too complex: cost 119 exceeds budget 80
.\collection.go:84:6: cannot inline (*Collection).next: function too complex: cost 259 exceeds budget 80
.\txn_cursor.go:224:6: cannot inline (*Cursor).updateChunkAt: unhandled op RANGE
.\txn_cursor.go:194:6: cannot inline (*Cursor).UpdateAt: function too complex: cost 93 exceeds budget 80
.\txn.go:253:6: cannot inline (*Txn).insert: unhandled op RANGE
.\txn.go:240:6: can inline (*Txn).Insert with cost 63 as: method(*Txn) func(map[string]interface {}) uint32 { return txn.insert(object, 0) }
.\collection.go:115:6: cannot inline (*Collection).Insert: unhandled op CLOSURE
.\collection.go:116:10: can inline (*Collection).Insert.func1 with cost 71 as: func(*Txn) error { index = txn.Insert(obj); return nil }
.\collection.go:117:21: inlining call to (*Txn).Insert method(*Txn) func(map[string]interface {}) uint32 { return txn.insert(object, 0) }
.\txn.go:247:6: cannot inline (*Txn).InsertWithTTL: function too complex: cost 228 exceeds budget 80
.\txn.go:248:56: inlining call to time.Time.UnixNano method(time.Time) func() int64 { return time.t.unixSec() * int64(1000000000) + int64(time.t.nsec()) }
.\txn.go:248:56: inlining call to time.(*Time).unixSec method(*time.Time) func() int64 { return time.t.sec() + int64(-62135596800) }
.\txn.go:248:56: inlining call to time.(*Time).sec method(*time.Time) func() int64 { if time.t.wall & uint64(9223372036854775808) != uint64(0) { return int64(59453308800) + int64(time.t.wall << uint(1) >> uint(31)) }; return time.t.ext }
.\txn.go:248:56: inlining call to time.(*Time).nsec method(*time.Time) func() int32 { return int32(time.t.wall & uint64(1073741823)) }
.\collection.go:125:6: cannot inline (*Collection).InsertWithTTL: unhandled op CLOSURE
.\collection.go:126:10: can inline (*Collection).InsertWithTTL.func1 with cost 66 as: func(*Txn) error { index = txn.InsertWithTTL(obj, ttl); return nil }
.\txn_cursor.go:214:6: cannot inline (*Cursor).updateChunk: function too complex: cost 122 exceeds budget 80
.\txn_cursor.go:172:6: cannot inline (*Cursor).Update: function too complex: cost 90 exceeds budget 80
.\collection.go:135:6: cannot inline (*Collection).UpdateAt: unhandled op CLOSURE
.\collection.go:136:10: cannot inline (*Collection).UpdateAt.func1: function too complex: cost 141 exceeds budget 80
.\txn.go:228:6: cannot inline (*Txn).DeleteAt: function too complex: cost 177 exceeds budget 80
.\txn.go:229:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\collection.go:147:6: cannot inline (*Collection).DeleteAt: unhandled op CLOSURE
.\collection.go:148:10: can inline (*Collection).DeleteAt.func1 with cost 65 as: func(*Txn) error { deleted = txn.DeleteAt(idx); return nil }
.\collection.go:156:6: can inline (*Collection).Count with cost 7 as: method(*Collection) func() int { return int(atomic.LoadUint64(&c.count)) }
.\column_numbers.go:21:6: can inline makeFloat32s with cost 12 as: func() Column { return &columnFloat32{...} }
.\column_numbers.go:151:6: can inline makeFloat64s with cost 12 as: func() Column { return &columnFloat64{...} }
.\column_numbers.go:281:6: can inline makeInts with cost 12 as: func() Column { return &columnInt{...} }
.\column_numbers.go:411:6: can inline makeInt16s with cost 12 as: func() Column { return &columnInt16{...} }
.\column_numbers.go:541:6: can inline makeInt32s with cost 12 as: func() Column { return &columnInt32{...} }
.\column_numbers.go:671:6: can inline makeInt64s with cost 12 as: func() Column { return &columnInt64{...} }
.\column_numbers.go:801:6: can inline makeUints with cost 12 as: func() Column { return &columnUint{...} }
.\column_numbers.go:931:6: can inline makeUint16s with cost 12 as: func() Column { return &columnUint16{...} }
.\column_numbers.go:1061:6: can inline makeUint32s with cost 12 as: func() Column { return &columnUint32{...} }
.\column_numbers.go:1191:6: can inline makeUint64s with cost 12 as: func() Column { return &columnUint64{...} }
.\column.go:286:6: can inline makeBools with cost 12 as: func() Column { return &columnBool{...} }
.\column.go:201:6: can inline makeAny with cost 12 as: func() Column { return &columnAny{...} }
.\column.go:86:6: cannot inline ForKind: function too complex: cost 205 exceeds budget 80
.\column.go:89:22: inlining call to makeFloat32s func() Column { return &columnFloat32{...} }
.\column.go:91:22: inlining call to makeFloat64s func() Column { return &columnFloat64{...} }
.\column.go:93:18: inlining call to makeInts func() Column { return &columnInt{...} }
.\column.go:95:20: inlining call to makeInt16s func() Column { return &columnInt16{...} }
.\column.go:97:20: inlining call to makeInt32s func() Column { return &columnInt32{...} }
.\column.go:99:20: inlining call to makeInt64s func() Column { return &columnInt64{...} }
.\column.go:101:19: inlining call to makeUints func() Column { return &columnUint{...} }
.\column.go:103:21: inlining call to makeUint16s func() Column { return &columnUint16{...} }
.\column.go:105:21: inlining call to makeUint32s func() Column { return &columnUint32{...} }
.\column.go:107:21: inlining call to makeUint64s func() Column { return &columnUint64{...} }
.\column.go:109:19: inlining call to makeBools func() Column { return &columnBool{...} }
.\column.go:111:17: inlining call to makeAny func() Column { return &columnAny{...} }
.\collection.go:161:6: cannot inline (*Collection).CreateColumnsOf: unhandled op RANGE
.\collection.go:163:43: inlining call to reflect.TypeOf func(interface {}) reflect.Type { var reflect.eface·3 reflect.emptyInterface; reflect.eface·3 = <N>; reflect.eface·3 = *(*reflect.emptyInterface)(unsafe.Pointer(&reflect.i)); return reflect.toType(reflect.eface·3.typ) }
.\collection.go:163:43: inlining call to reflect.toType func(*reflect.rtype) reflect.Type { if reflect.t == nil { return nil }; return reflect.Type(reflect.t) }
.\collection.go:421:6: cannot inline (*columns).DeleteColumn: unhandled op RANGE
.\collection.go:422:24: inlining call to atomic.(*Value).Load method(*atomic.Value) func() interface {} { var atomic.vp·3 *atomic.ifaceWords; atomic.vp·3 = <N>; atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)); var atomic.typ·4 unsafe.Pointer; atomic.typ·4 = <N>; atomic.typ·4 = atomic.LoadPointer(&atomic.vp·3.typ); if atomic.typ·4 == nil || uintptr(atomic.typ·4) == uintptr(18446744073709551615) { return nil }; var atomic.data·5 unsafe.Pointer; atomic.data·5 = <N>; atomic.data·5 = atomic.LoadPointer(&atomic.vp·3.data); var atomic.xp·6 *atomic.ifaceWords; atomic.xp·6 = <N>; atomic.xp·6 = (*atomic.ifaceWords)(unsafe.Pointer(&atomic.x)); atomic.xp·6.typ = atomic.typ·4; atomic.xp·6.data = atomic.data·5; return  }
.\collection.go:175:6: can inline (*Collection).DropColumn with cost 63 as: method(*Collection) func(string) { c.cols.DeleteColumn(columnName) }
.\column_index.go:26:6: can inline newIndex with cost 55 as: func(string, string, func(interface {}) bool) *column { return columnFor(indexName, &index{...}) }
.\column_index.go:27:18: inlining call to columnFor func(string, Column) *column { return &column{...} }
.\column_index.go:27:18: inlining call to typeOf func(Column) columnType { if ok { typ = typ | typeNumeric }; if ok { typ = typ | typeTextual }; return  }
.\column.go:155:6: can inline (*column).Value with cost 66 as: method(*column) func(uint32) (interface {}, bool) { v, ok = c.Column.Value(idx); return  }
.\collection.go:182:6: cannot inline (*Collection).CreateIndex: unhandled op DEFER
.\collection.go:190:19: inlining call to newIndex func(string, string, func(interface {}) bool) *column { return columnFor(indexName, &index{...}) }
.\collection.go:190:19: inlining call to columnFor func(string, Column) *column { return &column{...} }
.\collection.go:190:19: inlining call to typeOf func(Column) columnType { if ok { typ = typ | typeNumeric }; if ok { typ = typ | typeTextual }; return  }
.\collection.go:200:15: cannot inline (*Collection).CreateIndex.func1: function too complex: cost 142 exceeds budget 80
.\collection.go:201:28: inlining call to (*column).Value method(*column) func(uint32) (interface {}, bool) { v, ok = c.Column.Value(idx); return  }
.\collection.go:433:6: cannot inline (*columns).DeleteIndex: unhandled op RANGE
.\collection.go:439:24: inlining call to atomic.(*Value).Load method(*atomic.Value) func() interface {} { var atomic.vp·3 *atomic.ifaceWords; atomic.vp·3 = <N>; atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)); var atomic.typ·4 unsafe.Pointer; atomic.typ·4 = <N>; atomic.typ·4 = atomic.LoadPointer(&atomic.vp·3.typ); if atomic.typ·4 == nil || uintptr(atomic.typ·4) == uintptr(18446744073709551615) { return nil }; var atomic.data·5 unsafe.Pointer; atomic.data·5 = <N>; atomic.data·5 = atomic.LoadPointer(&atomic.vp·3.data); var atomic.xp·6 *atomic.ifaceWords; atomic.xp·6 = <N>; atomic.xp·6 = (*atomic.ifaceWords)(unsafe.Pointer(&atomic.x)); atomic.xp·6.typ = atomic.typ·4; atomic.xp·6.data = atomic.data·5; return  }
.\collection.go:212:6: cannot inline (*Collection).DropIndex: function too complex: cost 273 exceeds budget 80
.\collection.go:227:6: cannot inline (*Collection).Fetch: function too complex: cost 227 exceeds budget 80
.\collection.go:228:14: inlining call to sync.(*RWMutex).RLock method(*sync.RWMutex) func() { if bool(false) {  }; if atomic.AddInt32(&sync.rw.readerCount, int32(1)) < int32(0) { sync.runtime_SemacquireMutex(&sync.rw.readerSem, bool(false), int(0)) }; if bool(false) {  } }
.\collection.go:229:29: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\collection.go:230:16: inlining call to sync.(*RWMutex).RUnlock method(*sync.RWMutex) func() { if bool(false) {  }; if sync.r·2 < int32(0) { sync.rw.rUnlockSlow(sync.r·2) }; if bool(false) {  } }
.\collection.go:267:6: can inline (*Collection).Close with cost 62 as: method(*Collection) func() error { c.cancel(); return nil }
.\collection.go:294:6: cannot inline (*Collection).Replay: unhandled op CLOSURE
.\collection.go:295:17: cannot inline (*Collection).Replay.func1: unhandled op RANGE
.\collection.go:298:15: inlining call to commit.(*Commit).Is method(*commit.Commit) func(commit.Type) bool { return commit.c.Type & commit.t == commit.t }
.\collection.go:303:15: inlining call to commit.(*Commit).Is method(*commit.Commit) func(commit.Type) bool { return commit.c.Type & commit.t == commit.t }
.\collection.go:308:15: inlining call to commit.(*Commit).Is method(*commit.Commit) func(commit.Type) bool { return commit.c.Type & commit.t == commit.t }
.\column.go:134:6: can inline (*column).IsNumeric with cost 7 as: method(*column) func() bool { return c.kind & typeNumeric == typeNumeric }
.\column.go:139:6: can inline (*column).IsTextual with cost 7 as: method(*column) func() bool { return c.kind & typeTextual == typeTextual }
.\column.go:161:6: can inline (*column).String with cost 77 as: method(*column) func(uint32) (string, bool) { if text { v, ok = column.LoadString(idx) }; return  }
.\column.go:169:6: can inline (*column).Float64 with cost 77 as: method(*column) func(uint32) (float64, bool) { if contains { v, ok = n.LoadFloat64(idx) }; return  }
.\column.go:185:6: can inline (*column).Uint64 with cost 77 as: method(*column) func(uint32) (uint64, bool) { if contains { v, ok = n.LoadUint64(idx) }; return  }
.\column.go:336:6: can inline capacityFor with cost 34 as: func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column.go:209:6: cannot inline (*columnAny).Grow: function too complex: cost 143 exceeds budget 80
.\column.go:220:49: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column.go:226:6: cannot inline (*columnAny).Update: unhandled op RANGE
.\column.go:238:6: can inline (*columnAny).Delete with cost 70 as: method(*columnAny) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column.go:244:6: can inline (*columnAny).Value with cost 60 as: method(*columnAny) func(uint32) (interface {}, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column.go:245:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column.go:252:6: can inline (*columnAny).Contains with cost 44 as: method(*columnAny) func(uint32) bool { return c.fill.Contains(idx) }
.\column.go:253:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column.go:257:6: can inline (*columnAny).Index with cost 4 as: method(*columnAny) func() *bitmap.Bitmap { return &c.fill }
.\column.go:262:6: cannot inline (*columnAny).LoadString: function too complex: cost 85 exceeds budget 80
.\column.go:263:19: inlining call to (*columnAny).Value method(*columnAny) func(uint32) (interface {}, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column.go:263:19: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column.go:270:6: cannot inline (*columnAny).FilterString: unhandled op CLOSURE
.\column.go:272:15: can inline (*columnAny).FilterString.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(c.data[idx].(string)) }
.\column.go:294:6: can inline (*columnBool).Grow with cost 63 as: method(*columnBool) func(uint32) { c.fill.Grow(idx) }
.\column.go:299:6: cannot inline (*columnBool).Update: unhandled op RANGE
.\column.go:305:17: inlining call to bitmap.(*Bitmap).Remove method(*bitmap.Bitmap) func(uint32) { if bitmap.blkAt·3 < len(*bitmap.dst) { var bitmap.bitAt·4 int; bitmap.bitAt·4 = <N>; bitmap.bitAt·4 = int(bitmap.x % uint32(64)); (*bitmap.dst)[bitmap.blkAt·3] &^= uint64(1) << bitmap.bitAt·4 } }
.\column.go:311:6: cannot inline (*columnBool).Value: function too complex: cost 88 exceeds budget 80
.\column.go:312:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column.go:312:46: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column.go:316:6: can inline (*columnBool).Delete with cost 70 as: method(*columnBool) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column.go:324:6: can inline (*columnBool).Contains with cost 44 as: method(*columnBool) func(uint32) bool { return c.fill.Contains(idx) }
.\column.go:325:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column.go:329:6: can inline (*columnBool).Index with cost 4 as: method(*columnBool) func() *bitmap.Bitmap { return &c.data }
.\column_generate.go:20:6: can inline makenumbers with cost 12 as: func() Column { return &columnnumber{...} }
.\column_generate.go:28:6: cannot inline (*columnnumber).Grow: function too complex: cost 143 exceeds budget 80
.\column_generate.go:39:44: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_generate.go:45:6: cannot inline (*columnnumber).Update: unhandled op RANGE
.\column_generate.go:69:6: can inline (*columnnumber).Delete with cost 70 as: method(*columnnumber) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_generate.go:75:6: can inline (*columnnumber).Contains with cost 44 as: method(*columnnumber) func(uint32) bool { return c.fill.Contains(idx) }
.\column_generate.go:76:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_generate.go:80:6: can inline (*columnnumber).Index with cost 4 as: method(*columnnumber) func() *bitmap.Bitmap { return &c.fill }
.\column_generate.go:85:6: can inline (*columnnumber).Value with cost 65 as: method(*columnnumber) func(uint32) (interface {}, bool) { v = number(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_generate.go:87:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_generate.go:94:6: can inline (*columnnumber).LoadFloat64 with cost 61 as: method(*columnnumber) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_generate.go:95:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_generate.go:102:6: can inline (*columnnumber).LoadInt64 with cost 61 as: method(*columnnumber) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_generate.go:103:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_generate.go:110:6: can inline (*columnnumber).LoadUint64 with cost 61 as: method(*columnnumber) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_generate.go:111:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_generate.go:118:6: cannot inline (*columnnumber).FilterFloat64: unhandled op CLOSURE
.\column_generate.go:120:15: can inline (*columnnumber).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_generate.go:126:6: cannot inline (*columnnumber).FilterInt64: unhandled op CLOSURE
.\column_generate.go:128:15: can inline (*columnnumber).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_generate.go:134:6: cannot inline (*columnnumber).FilterUint64: unhandled op CLOSURE
.\column_generate.go:136:15: can inline (*columnnumber).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_index.go:35:6: can inline (*index).Grow with cost 63 as: method(*index) func(uint32) { c.fill.Grow(idx) }
.\column_index.go:40:6: can inline (*index).Column with cost 3 as: method(*index) func() string { return c.prop }
.\column_index.go:45:6: cannot inline (*index).Update: unhandled op RANGE
.\column_index.go:55:18: inlining call to bitmap.(*Bitmap).Remove method(*bitmap.Bitmap) func(uint32) { if bitmap.blkAt·3 < len(*bitmap.dst) { var bitmap.bitAt·4 int; bitmap.bitAt·4 = <N>; bitmap.bitAt·4 = int(bitmap.x % uint32(64)); (*bitmap.dst)[bitmap.blkAt·3] &^= uint64(1) << bitmap.bitAt·4 } }
.\column_index.go:62:6: can inline (*index).Delete with cost 70 as: method(*index) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_index.go:68:6: can inline (*index).Value with cost 58 as: method(*index) func(uint32) (interface {}, bool) { if idx < uint32(len(c.fill)) << 6 { v, ok = <N> }; return  }
.\column_index.go:70:26: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_index.go:76:6: can inline (*index).Contains with cost 44 as: method(*index) func(uint32) bool { return c.fill.Contains(idx) }
.\column_index.go:77:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_index.go:81:6: can inline (*index).Index with cost 4 as: method(*index) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:29:6: cannot inline (*columnFloat32).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:40:45: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:46:6: cannot inline (*columnFloat32).Update: unhandled op RANGE
.\column_numbers.go:70:6: can inline (*columnFloat32).Delete with cost 70 as: method(*columnFloat32) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:76:6: can inline (*columnFloat32).Contains with cost 44 as: method(*columnFloat32) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:77:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:81:6: can inline (*columnFloat32).Index with cost 4 as: method(*columnFloat32) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:86:6: can inline (*columnFloat32).Value with cost 65 as: method(*columnFloat32) func(uint32) (interface {}, bool) { v = float32(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:88:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:95:6: can inline (*columnFloat32).LoadFloat64 with cost 61 as: method(*columnFloat32) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:96:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:103:6: can inline (*columnFloat32).LoadInt64 with cost 61 as: method(*columnFloat32) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:104:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:111:6: can inline (*columnFloat32).LoadUint64 with cost 61 as: method(*columnFloat32) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:112:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:119:6: cannot inline (*columnFloat32).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:121:15: can inline (*columnFloat32).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:127:6: cannot inline (*columnFloat32).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:129:15: can inline (*columnFloat32).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:135:6: cannot inline (*columnFloat32).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:137:15: can inline (*columnFloat32).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:159:6: cannot inline (*columnFloat64).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:170:45: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:176:6: cannot inline (*columnFloat64).Update: unhandled op RANGE
.\column_numbers.go:200:6: can inline (*columnFloat64).Delete with cost 70 as: method(*columnFloat64) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:206:6: can inline (*columnFloat64).Contains with cost 44 as: method(*columnFloat64) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:207:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:211:6: can inline (*columnFloat64).Index with cost 4 as: method(*columnFloat64) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:216:6: can inline (*columnFloat64).Value with cost 65 as: method(*columnFloat64) func(uint32) (interface {}, bool) { v = float64(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:218:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:225:6: can inline (*columnFloat64).LoadFloat64 with cost 61 as: method(*columnFloat64) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:226:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:233:6: can inline (*columnFloat64).LoadInt64 with cost 61 as: method(*columnFloat64) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:234:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:241:6: can inline (*columnFloat64).LoadUint64 with cost 61 as: method(*columnFloat64) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:242:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:249:6: cannot inline (*columnFloat64).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:251:15: can inline (*columnFloat64).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:257:6: cannot inline (*columnFloat64).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:259:15: can inline (*columnFloat64).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:265:6: cannot inline (*columnFloat64).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:267:15: can inline (*columnFloat64).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:289:6: cannot inline (*columnInt).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:300:41: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:306:6: cannot inline (*columnInt).Update: unhandled op RANGE
.\column_numbers.go:330:6: can inline (*columnInt).Delete with cost 70 as: method(*columnInt) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:336:6: can inline (*columnInt).Contains with cost 44 as: method(*columnInt) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:337:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:341:6: can inline (*columnInt).Index with cost 4 as: method(*columnInt) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:346:6: can inline (*columnInt).Value with cost 65 as: method(*columnInt) func(uint32) (interface {}, bool) { v = int(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:348:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:355:6: can inline (*columnInt).LoadFloat64 with cost 61 as: method(*columnInt) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:356:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:363:6: can inline (*columnInt).LoadInt64 with cost 61 as: method(*columnInt) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:364:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:371:6: can inline (*columnInt).LoadUint64 with cost 61 as: method(*columnInt) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:372:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:379:6: cannot inline (*columnInt).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:381:15: can inline (*columnInt).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:387:6: cannot inline (*columnInt).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:389:15: can inline (*columnInt).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:395:6: cannot inline (*columnInt).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:397:15: can inline (*columnInt).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:419:6: cannot inline (*columnInt16).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:430:43: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:436:6: cannot inline (*columnInt16).Update: unhandled op RANGE
.\column_numbers.go:460:6: can inline (*columnInt16).Delete with cost 70 as: method(*columnInt16) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:466:6: can inline (*columnInt16).Contains with cost 44 as: method(*columnInt16) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:467:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:471:6: can inline (*columnInt16).Index with cost 4 as: method(*columnInt16) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:476:6: can inline (*columnInt16).Value with cost 65 as: method(*columnInt16) func(uint32) (interface {}, bool) { v = int16(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:478:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:485:6: can inline (*columnInt16).LoadFloat64 with cost 61 as: method(*columnInt16) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:486:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:493:6: can inline (*columnInt16).LoadInt64 with cost 61 as: method(*columnInt16) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:494:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:501:6: can inline (*columnInt16).LoadUint64 with cost 61 as: method(*columnInt16) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:502:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:509:6: cannot inline (*columnInt16).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:511:15: can inline (*columnInt16).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:517:6: cannot inline (*columnInt16).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:519:15: can inline (*columnInt16).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:525:6: cannot inline (*columnInt16).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:527:15: can inline (*columnInt16).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:549:6: cannot inline (*columnInt32).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:560:43: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:566:6: cannot inline (*columnInt32).Update: unhandled op RANGE
.\column_numbers.go:590:6: can inline (*columnInt32).Delete with cost 70 as: method(*columnInt32) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:596:6: can inline (*columnInt32).Contains with cost 44 as: method(*columnInt32) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:597:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:601:6: can inline (*columnInt32).Index with cost 4 as: method(*columnInt32) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:606:6: can inline (*columnInt32).Value with cost 65 as: method(*columnInt32) func(uint32) (interface {}, bool) { v = int32(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:608:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:615:6: can inline (*columnInt32).LoadFloat64 with cost 61 as: method(*columnInt32) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:616:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:623:6: can inline (*columnInt32).LoadInt64 with cost 61 as: method(*columnInt32) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:624:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:631:6: can inline (*columnInt32).LoadUint64 with cost 61 as: method(*columnInt32) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:632:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:639:6: cannot inline (*columnInt32).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:641:15: can inline (*columnInt32).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:647:6: cannot inline (*columnInt32).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:649:15: can inline (*columnInt32).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:655:6: cannot inline (*columnInt32).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:657:15: can inline (*columnInt32).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:679:6: cannot inline (*columnInt64).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:690:43: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:696:6: cannot inline (*columnInt64).Update: unhandled op RANGE
.\column_numbers.go:720:6: can inline (*columnInt64).Delete with cost 70 as: method(*columnInt64) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:726:6: can inline (*columnInt64).Contains with cost 44 as: method(*columnInt64) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:727:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:731:6: can inline (*columnInt64).Index with cost 4 as: method(*columnInt64) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:736:6: can inline (*columnInt64).Value with cost 65 as: method(*columnInt64) func(uint32) (interface {}, bool) { v = int64(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:738:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:745:6: can inline (*columnInt64).LoadFloat64 with cost 61 as: method(*columnInt64) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:746:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:753:6: can inline (*columnInt64).LoadInt64 with cost 61 as: method(*columnInt64) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:754:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:761:6: can inline (*columnInt64).LoadUint64 with cost 61 as: method(*columnInt64) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:762:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:769:6: cannot inline (*columnInt64).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:771:15: can inline (*columnInt64).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:777:6: cannot inline (*columnInt64).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:779:15: can inline (*columnInt64).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:785:6: cannot inline (*columnInt64).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:787:15: can inline (*columnInt64).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:809:6: cannot inline (*columnUint).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:820:42: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:826:6: cannot inline (*columnUint).Update: unhandled op RANGE
.\column_numbers.go:850:6: can inline (*columnUint).Delete with cost 70 as: method(*columnUint) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:856:6: can inline (*columnUint).Contains with cost 44 as: method(*columnUint) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:857:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:861:6: can inline (*columnUint).Index with cost 4 as: method(*columnUint) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:866:6: can inline (*columnUint).Value with cost 65 as: method(*columnUint) func(uint32) (interface {}, bool) { v = uint(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:868:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:875:6: can inline (*columnUint).LoadFloat64 with cost 61 as: method(*columnUint) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:876:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:883:6: can inline (*columnUint).LoadInt64 with cost 61 as: method(*columnUint) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:884:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:891:6: can inline (*columnUint).LoadUint64 with cost 61 as: method(*columnUint) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:892:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:899:6: cannot inline (*columnUint).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:901:15: can inline (*columnUint).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:907:6: cannot inline (*columnUint).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:909:15: can inline (*columnUint).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:915:6: cannot inline (*columnUint).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:917:15: can inline (*columnUint).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:939:6: cannot inline (*columnUint16).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:950:44: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:956:6: cannot inline (*columnUint16).Update: unhandled op RANGE
.\column_numbers.go:980:6: can inline (*columnUint16).Delete with cost 70 as: method(*columnUint16) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:986:6: can inline (*columnUint16).Contains with cost 44 as: method(*columnUint16) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:987:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:991:6: can inline (*columnUint16).Index with cost 4 as: method(*columnUint16) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:996:6: can inline (*columnUint16).Value with cost 65 as: method(*columnUint16) func(uint32) (interface {}, bool) { v = uint16(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:998:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1005:6: can inline (*columnUint16).LoadFloat64 with cost 61 as: method(*columnUint16) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1006:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1013:6: can inline (*columnUint16).LoadInt64 with cost 61 as: method(*columnUint16) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1014:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1021:6: can inline (*columnUint16).LoadUint64 with cost 61 as: method(*columnUint16) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1022:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1029:6: cannot inline (*columnUint16).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:1031:15: can inline (*columnUint16).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:1037:6: cannot inline (*columnUint16).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:1039:15: can inline (*columnUint16).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:1045:6: cannot inline (*columnUint16).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:1047:15: can inline (*columnUint16).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:1069:6: cannot inline (*columnUint32).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:1080:44: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:1086:6: cannot inline (*columnUint32).Update: unhandled op RANGE
.\column_numbers.go:1110:6: can inline (*columnUint32).Delete with cost 70 as: method(*columnUint32) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:1116:6: can inline (*columnUint32).Contains with cost 44 as: method(*columnUint32) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:1117:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1121:6: can inline (*columnUint32).Index with cost 4 as: method(*columnUint32) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:1126:6: can inline (*columnUint32).Value with cost 65 as: method(*columnUint32) func(uint32) (interface {}, bool) { v = uint32(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1128:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1135:6: can inline (*columnUint32).LoadFloat64 with cost 61 as: method(*columnUint32) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1136:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1143:6: can inline (*columnUint32).LoadInt64 with cost 61 as: method(*columnUint32) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1144:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1151:6: can inline (*columnUint32).LoadUint64 with cost 61 as: method(*columnUint32) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1152:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1159:6: cannot inline (*columnUint32).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:1161:15: can inline (*columnUint32).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:1167:6: cannot inline (*columnUint32).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:1169:15: can inline (*columnUint32).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:1175:6: cannot inline (*columnUint32).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:1177:15: can inline (*columnUint32).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_numbers.go:1199:6: cannot inline (*columnUint64).Grow: function too complex: cost 143 exceeds budget 80
.\column_numbers.go:1210:44: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_numbers.go:1216:6: cannot inline (*columnUint64).Update: unhandled op RANGE
.\column_numbers.go:1240:6: can inline (*columnUint64).Delete with cost 70 as: method(*columnUint64) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_numbers.go:1246:6: can inline (*columnUint64).Contains with cost 44 as: method(*columnUint64) func(uint32) bool { return c.fill.Contains(idx) }
.\column_numbers.go:1247:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1251:6: can inline (*columnUint64).Index with cost 4 as: method(*columnUint64) func() *bitmap.Bitmap { return &c.fill }
.\column_numbers.go:1256:6: can inline (*columnUint64).Value with cost 65 as: method(*columnUint64) func(uint32) (interface {}, bool) { v = uint64(0); if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1258:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1265:6: can inline (*columnUint64).LoadFloat64 with cost 61 as: method(*columnUint64) func(uint32) (float64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1266:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1273:6: can inline (*columnUint64).LoadInt64 with cost 61 as: method(*columnUint64) func(uint32) (int64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1274:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1281:6: can inline (*columnUint64).LoadUint64 with cost 61 as: method(*columnUint64) func(uint32) (uint64, bool) { if idx < uint32(len(c.data)) && c.fill.Contains(idx) { v, ok = <N> }; return  }
.\column_numbers.go:1282:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_numbers.go:1289:6: cannot inline (*columnUint64).FilterFloat64: unhandled op CLOSURE
.\column_numbers.go:1291:15: can inline (*columnUint64).FilterFloat64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(float64(c.data[idx])) }
.\column_numbers.go:1297:6: cannot inline (*columnUint64).FilterInt64: unhandled op CLOSURE
.\column_numbers.go:1299:15: can inline (*columnUint64).FilterInt64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(int64(c.data[idx])) }
.\column_numbers.go:1305:6: cannot inline (*columnUint64).FilterUint64: unhandled op CLOSURE
.\column_numbers.go:1307:15: can inline (*columnUint64).FilterUint64.func1 with cost 72 as: func(uint32) bool { return idx < uint32(len(c.data)) && predicate(uint64(c.data[idx])) }
.\column_strings.go:27:6: can inline makeEnum with cost 19 as: func() Column { return &columnEnum{...} }
.\column_strings.go:37:6: cannot inline (*columnEnum).Grow: function too complex: cost 143 exceeds budget 80
.\column_strings.go:48:44: inlining call to capacityFor func(uint32) int { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return int(v) }
.\column_strings.go:217:6: can inline toBytes with cost 36 as: func(string) []byte { strHeader := (*reflect.StringHeader)(unsafe.Pointer(&v)); byteHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b)); byteHeader.Data = strHeader.Data; l := len(v); byteHeader.Len = l; byteHeader.Cap = l; return  }
.\column_strings.go:180:6: cannot inline hashBytes32: function too complex: cost 187 exceeds budget 80
.\column_strings.go:175:6: can inline hash32 with cost 62 as: func([]byte) uint32 { return hashBytes32(init32, b) }
.\column_strings.go:74:6: cannot inline (*columnEnum).findOrAdd: function too complex: cost 276 exceeds budget 80
.\column_strings.go:75:18: inlining call to toBytes func(string) []byte { strHeader := (*reflect.StringHeader)(unsafe.Pointer(&v)); byteHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b)); byteHeader.Data = strHeader.Data; l := len(v); byteHeader.Len = l; byteHeader.Cap = l; return  }
.\column_strings.go:76:18: inlining call to hash32 func([]byte) uint32 { return hashBytes32(init32, b) }
.\column_strings.go:78:34: inlining call to binary.bigEndian.Uint32 method(binary.bigEndian) func([]byte) uint32 { _ = binary.b[int(3)]; return uint32(binary.b[int(3)]) | uint32(binary.b[int(2)]) << uint(8) | uint32(binary.b[int(1)]) << uint(16) | uint32(binary.b[int(0)]) << uint(24) }
.\column_strings.go:89:28: inlining call to binary.bigEndian.PutUint32 method(binary.bigEndian) func([]byte, uint32) { _ = binary.b[int(3)]; binary.b[int(0)] = byte(binary.v >> uint(24)); binary.b[int(1)] = byte(binary.v >> uint(16)); binary.b[int(2)] = byte(binary.v >> uint(8)); binary.b[int(3)] = byte(binary.v) }
.\column_strings.go:54:6: cannot inline (*columnEnum).Update: unhandled op RANGE
.\column_strings.go:229:6: can inline toString with cost 5 as: func(*[]byte) string { return *(*string)(unsafe.Pointer(b)) }
.\column_strings.go:98:6: can inline (*columnEnum).readAt with cost 34 as: method(*columnEnum) func(uint32) string { size := uint32(c.data[at]); data := c.data[at + 1:at + 1 + size]; return toString(&data) }
.\column_strings.go:101:17: inlining call to toString func(*[]byte) string { return *(*string)(unsafe.Pointer(b)) }
.\column_strings.go:105:6: can inline (*columnEnum).Delete with cost 70 as: method(*columnEnum) func(int, bitmap.Bitmap) { fill := c.fill[offset:]; fill.AndNot(items) }
.\column_strings.go:119:6: cannot inline (*columnEnum).LoadString: function too complex: cost 97 exceeds budget 80
.\column_strings.go:120:49: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_strings.go:121:19: inlining call to (*columnEnum).readAt method(*columnEnum) func(uint32) string { size := uint32(c.data[at]); data := c.data[at + 1:at + 1 + size]; return toString(&data) }
.\column_strings.go:121:19: inlining call to toString func(*[]byte) string { return *(*string)(unsafe.Pointer(b)) }
.\column_strings.go:114:6: can inline (*columnEnum).Value with cost 72 as: method(*columnEnum) func(uint32) (interface {}, bool) { return c.LoadString(idx) }
.\column_strings.go:128:6: cannot inline (*columnEnum).FilterString: unhandled op CLOSURE
.\column_strings.go:141:15: cannot inline (*columnEnum).FilterString.func1: function too complex: cost 132 exceeds budget 80
.\column_strings.go:145:37: inlining call to (*columnEnum).readAt method(*columnEnum) func(uint32) string { size := uint32(c.data[at]); data := c.data[at + 1:at + 1 + size]; return toString(&data) }
.\column_strings.go:145:37: inlining call to toString func(*[]byte) string { return *(*string)(unsafe.Pointer(b)) }
.\column_strings.go:157:6: can inline (*columnEnum).Contains with cost 44 as: method(*columnEnum) func(uint32) bool { return c.fill.Contains(idx) }
.\column_strings.go:158:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\column_strings.go:162:6: can inline (*columnEnum).Index with cost 4 as: method(*columnEnum) func() *bitmap.Bitmap { return &c.fill }
.\txn.go:105:6: cannot inline (*Txn).Without: unhandled op RANGE
.\txn.go:108:43: can inline (*Txn).Without.func1 with cost 62 as: func(bitmap.Bitmap, bitmap.Bitmap) { dst.AndNot(src) }
.\txn.go:117:6: cannot inline (*Txn).Union: unhandled op RANGE
.\txn.go:120:43: can inline (*Txn).Union.func1 with cost 62 as: func(bitmap.Bitmap, bitmap.Bitmap) { dst.Or(src) }
.\txn.go:130:6: cannot inline (*Txn).WithValue: unhandled op CLOSURE
.\txn.go:137:16: cannot inline (*Txn).WithValue.func1: unhandled op CLOSURE
.\txn.go:138:16: cannot inline (*Txn).WithValue.func1.1: function too complex: cost 142 exceeds budget 80
.\txn.go:139:23: inlining call to (*column).Value method(*column) func(uint32) (interface {}, bool) { v, ok = c.Column.Value(idx); return  }
.\txn.go:150:6: cannot inline (*Txn).WithFloat: unhandled op CLOSURE
.\txn.go:152:24: inlining call to (*column).IsNumeric method(*column) func() bool { return c.kind & typeNumeric == typeNumeric }
.\txn.go:157:16: can inline (*Txn).WithFloat.func1 with cost 65 as: func(uint32, bitmap.Bitmap) { c.Column.(Numeric).FilterFloat64(&index, predicate) }
.\txn.go:165:6: cannot inline (*Txn).WithInt: unhandled op CLOSURE
.\txn.go:167:24: inlining call to (*column).IsNumeric method(*column) func() bool { return c.kind & typeNumeric == typeNumeric }
.\txn.go:172:16: can inline (*Txn).WithInt.func1 with cost 65 as: func(uint32, bitmap.Bitmap) { c.Column.(Numeric).FilterInt64(&index, predicate) }
.\txn.go:180:6: cannot inline (*Txn).WithUint: unhandled op CLOSURE
.\txn.go:182:24: inlining call to (*column).IsNumeric method(*column) func() bool { return c.kind & typeNumeric == typeNumeric }
.\txn.go:187:16: can inline (*Txn).WithUint.func1 with cost 65 as: func(uint32, bitmap.Bitmap) { c.Column.(Numeric).FilterUint64(&index, predicate) }
.\txn.go:195:6: cannot inline (*Txn).WithString: unhandled op CLOSURE
.\txn.go:197:24: inlining call to (*column).IsTextual method(*column) func() bool { return c.kind & typeTextual == typeTextual }
.\txn.go:202:16: can inline (*Txn).WithString.func1 with cost 65 as: func(uint32, bitmap.Bitmap) { c.Column.(Textual).FilterString(&index, predicate) }
.\txn.go:209:6: can inline (*Txn).Count with cost 63 as: method(*Txn) func() int { return int(txn.index.Count()) }
.\txn.go:215:6: can inline (*Txn).ReadAt with cost 55 as: method(*Txn) func(uint32) (Selector, bool) { if !txn.index.Contains(index) { return Selector{}, false }; return Selector{...}, true }
.\txn.go:216:24: inlining call to bitmap.Bitmap.Contains method(bitmap.Bitmap) func(uint32) bool { var bitmap.blkAt·4 int; bitmap.blkAt·4 = <N>; bitmap.blkAt·4 = int(bitmap.x >> uint(6)); if bitmap.blkAt·4 >= bitmap.size·5 { return bool(false) }; var bitmap.bitAt·6 int; bitmap.bitAt·6 = <N>; bitmap.bitAt·6 = int(bitmap.x % uint32(64)); return bitmap.dst[bitmap.blkAt·4] & (uint64(1) << bitmap.bitAt·6) > uint64(0) }
.\txn.go:280:6: cannot inline (*Txn).Select: unhandled op CLOSURE
.\txn.go:281:16: cannot inline (*Txn).Select.func1: unhandled op CLOSURE
.\txn.go:282:15: can inline (*Txn).Select.func1.1 with cost 66 as: func(uint32) { fn(Selector{...}) }
.\txn.go:294:6: cannot inline (*Txn).DeleteIf: unhandled op CLOSURE
.\txn.go:295:18: cannot inline (*Txn).DeleteIf.func1: function too complex: cost 193 exceeds budget 80
.\txn.go:305:6: cannot inline (*Txn).DeleteAll: unhandled op CLOSURE
.\txn.go:309:20: can inline (*Txn).DeleteAll.func1 with cost 65 as: func(uint32) { txn.dirty.Set(x >> chunkShift) }
.\txn_cursor.go:60:6: cannot inline (*Selector).columnAt: function too complex: cost 151 exceeds budget 80
.\txn_cursor.go:70:6: cannot inline (*Selector).ValueAt: function too complex: cost 145 exceeds budget 80
.\txn_cursor.go:72:19: inlining call to (*column).Value method(*column) func(uint32) (interface {}, bool) { v, ok = c.Column.Value(idx); return  }
.\txn_cursor.go:78:6: cannot inline (*Selector).StringAt: function too complex: cost 156 exceeds budget 80
.\txn_cursor.go:80:20: inlining call to (*column).String method(*column) func(uint32) (string, bool) { if text { v, ok = column.LoadString(idx) }; return  }
.\txn_cursor.go:86:6: cannot inline (*Selector).FloatAt: function too complex: cost 156 exceeds budget 80
.\txn_cursor.go:88:21: inlining call to (*column).Float64 method(*column) func(uint32) (float64, bool) { if contains { v, ok = n.LoadFloat64(idx) }; return  }
.\txn_cursor.go:94:6: cannot inline (*Selector).IntAt: function too complex: cost 156 exceeds budget 80
.\txn_cursor.go:96:19: inlining call to (*column).Int64 method(*column) func(uint32) (int64, bool) { if contains { v, ok = n.LoadInt64(idx) }; return  }
.\txn_cursor.go:102:6: cannot inline (*Selector).UintAt: function too complex: cost 156 exceeds budget 80
.\txn_cursor.go:104:20: inlining call to (*column).Uint64 method(*column) func(uint32) (uint64, bool) { if contains { v, ok = n.LoadUint64(idx) }; return  }
.\txn_cursor.go:110:6: cannot inline (*Selector).BoolAt: function too complex: cost 136 exceeds budget 80
.\txn_cursor.go:127:6: can inline (*Cursor).Value with cost 77 as: method(*Cursor) func() interface {} { out, _ = cur.column.Value(cur.Selector.idx); return  }
.\txn_cursor.go:128:27: inlining call to (*column).Value method(*column) func(uint32) (interface {}, bool) { v, ok = c.Column.Value(idx); return  }
.\txn_cursor.go:133:6: cannot inline (*Cursor).String: function too complex: cost 88 exceeds budget 80
.\txn_cursor.go:134:28: inlining call to (*column).String method(*column) func(uint32) (string, bool) { if text { v, ok = column.LoadString(idx) }; return  }
.\txn_cursor.go:139:6: cannot inline (*Cursor).Float: function too complex: cost 88 exceeds budget 80
.\txn_cursor.go:140:29: inlining call to (*column).Float64 method(*column) func(uint32) (float64, bool) { if contains { v, ok = n.LoadFloat64(idx) }; return  }
.\txn_cursor.go:151:6: cannot inline (*Cursor).Uint: function too complex: cost 88 exceeds budget 80
.\txn_cursor.go:152:28: inlining call to (*column).Uint64 method(*column) func(uint32) (uint64, bool) { if contains { v, ok = n.LoadUint64(idx) }; return  }
.\txn_cursor.go:157:6: can inline (*Cursor).Bool with cost 66 as: method(*Cursor) func() bool { return cur.column.Column.Contains(cur.Selector.idx) }
.\txn_cursor.go:183:6: cannot inline (*Cursor).Add: function too complex: cost 90 exceeds budget 80
.\txn_cursor.go:205:6: cannot inline (*Cursor).AddAt: function too complex: cost 93 exceeds budget 80
.\txn.go:19:7: can inline glob..func1 with cost 28 as: func() interface {} { return &Txn{...} }
.\collection.go:405:15: columns escapes to heap:
.\collection.go:405:15:   flow: {heap} = &{storage for columns}:
.\collection.go:405:15:     from columns (spill) at .\collection.go:405:15
.\collection.go:405:15:     from c.cols.Store(columns) (call parameter) at .\collection.go:405:15
.\collection.go:417:14: columns escapes to heap:
.\collection.go:417:14:   flow: {heap} = &{storage for columns}:
.\collection.go:417:14:     from columns (spill) at .\collection.go:417:14
.\collection.go:417:14:     from c.cols.Store(columns) (call parameter) at .\collection.go:417:14
.\collection.go:411:20: []*column{...} escapes to heap:
.\collection.go:411:20:   flow: value = &{storage for []*column{...}}:
.\collection.go:411:20:     from []*column{...} (spill) at .\collection.go:411:20
.\collection.go:411:20:     from value := []*column{...} (assign) at .\collection.go:411:8
.\collection.go:411:20:   flow: {heap} = value:
.\collection.go:411:20:     from columnEntry{...} (struct literal element) at .\collection.go:413:39
.\collection.go:411:20:     from append(columns, columnEntry{...}) (call parameter) at .\collection.go:413:18
.\collection.go:389:25: parameter columnName leaks to {heap} with derefs=0:
.\collection.go:389:25:   flow: {heap} = columnName:
.\collection.go:389:25:     from columnEntry{...} (struct literal element) at .\collection.go:413:39
.\collection.go:389:25:     from append(columns, columnEntry{...}) (call parameter) at .\collection.go:413:18
.\collection.go:389:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:389:7:   flow: {heap} = *c:
.\collection.go:389:7:     from c.cols (dot of pointer) at .\collection.go:405:4
.\collection.go:389:7:     from c.cols.Store(columns) (call parameter) at .\collection.go:405:15
.\collection.go:389:58: parameter index leaks to {heap} with derefs=1:
.\collection.go:389:58:   flow: {heap} = *index:
.\collection.go:389:58:     from append(columns[i].cols, index...) (call parameter) at .\collection.go:403:28
.\collection.go:389:58:     from append(columns[i].cols, index...) (appended slice...) at .\collection.go:403:28
.\collection.go:389:44: parameter main leaks to {heap} with derefs=0:
.\collection.go:389:44:   flow: {heap} = main:
.\collection.go:389:44:     from columns[i].cols[0] = main (assign) at .\collection.go:400:23
.\collection.go:389:44: parameter main leaks to {storage for []*column{...}} with derefs=0:
.\collection.go:389:44:   flow: {storage for []*column{...}} = main:
.\collection.go:389:44:     from []*column{...} (slice-literal-element) at .\collection.go:411:20
.\collection.go:389:7: leaking param content: c
.\collection.go:389:25: leaking param: columnName
.\collection.go:389:44: leaking param: main
.\collection.go:389:58: leaking param content: index
.\collection.go:405:15: columns escapes to heap
.\collection.go:411:20: []*column{...} escapes to heap
.\collection.go:417:14: columns escapes to heap
.\collection.go:170:36: &column{...} escapes to heap:
.\collection.go:170:36:   flow: ~R0 = &{storage for &column{...}}:
.\collection.go:170:36:     from &column{...} (spill) at .\collection.go:170:36
.\collection.go:170:36:     from ~R0 = <N> (assign-pair) at .\collection.go:170:36
.\collection.go:170:36:   flow: {heap} = ~R0:
.\collection.go:170:36:     from c.cols.Store(columnName, (*column)(~R0), []*column(nil)...) (call parameter) at .\collection.go:170:14
.\collection.go:168:35: parameter columnName leaks to {heap} with derefs=0:
.\collection.go:168:35:   flow: {heap} = columnName:
.\collection.go:168:35:     from c.cols.Store(columnName, (*column)(~R0), []*column(nil)...) (call parameter) at .\collection.go:170:14
.\collection.go:168:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:168:7:   flow: {heap} = *c:
.\collection.go:168:7:     from c.cols (dot of pointer) at .\collection.go:170:3
.\collection.go:168:7:     from c.cols (address-of) at .\collection.go:170:8
.\collection.go:168:7:     from c.cols.Store(columnName, (*column)(~R0), []*column(nil)...) (call parameter) at .\collection.go:170:14
.\collection.go:168:54: parameter column leaks to {heap} with derefs=0:
.\collection.go:168:54:   flow: {heap} = column:
.\collection.go:168:54:     from column.Grow(uint32(c.size)) (call parameter) at .\collection.go:169:13
.\collection.go:168:54: parameter column leaks to {storage for &column{...}} with derefs=0:
.\collection.go:168:54:   flow: v = column:
.\collection.go:168:54:     from name, v := columnName, column (assign-pair) at .\collection.go:170:36
.\collection.go:168:54:   flow: {storage for &column{...}} = v:
.\collection.go:168:54:     from column{...} (struct literal element) at .\collection.go:170:36
.\collection.go:168:35: parameter columnName leaks to {storage for &column{...}} with derefs=0:
.\collection.go:168:35:   flow: name = columnName:
.\collection.go:168:35:     from name, v := columnName, column (assign-pair) at .\collection.go:170:36
.\collection.go:168:35:   flow: {storage for &column{...}} = name:
.\collection.go:168:35:     from column{...} (struct literal element) at .\collection.go:170:36
.\collection.go:168:7: leaking param content: c
.\collection.go:168:35: leaking param: columnName
.\collection.go:168:54: leaking param: column
.\collection.go:170:36: &column{...} escapes to heap
.\txn.go:332:7: parameter txn leaks to {heap} with derefs=2:
.\txn.go:332:7:   flow: {heap} = **txn:
.\txn.go:332:7:     from txn.updates (dot of pointer) at .\txn.go:339:30
.\txn.go:332:7:     from txn.updates[i] (dot of pointer) at .\txn.go:339:38
.\txn.go:332:7:     from txn.updates[i].Update (dot) at .\txn.go:339:41
.\txn.go:332:7:     from txn.updates[i].Update[:0] (slice) at .\txn.go:339:48
.\txn.go:332:7:     from txn.updates[i].Update = txn.updates[i].Update[:0] (assign) at .\txn.go:339:25
.\txn.go:332:7: leaking param content: txn
.\txn.go:36:14: aquireTxn ignoring self-assignment in txn.columns = txn.columns[:0]
.\txn.go:32:16: parameter owner leaks to {heap} with derefs=0:
.\txn.go:32:16:   flow: {heap} = owner:
.\txn.go:32:16:     from txn.owner = owner (assign) at .\txn.go:35:12
.\txn.go:32:16: leaking param: owner
.\tnx_lock.go:59:2: lock escapes to heap:
.\tnx_lock.go:59:2:   flow: smutex.rw = &lock:
.\tnx_lock.go:59:2:     from lock (address-of) at .\tnx_lock.go:70:7
.\tnx_lock.go:59:2:     from smutex.rw, smutex.shard := lock, uint(chunk) (assign-pair) at .\tnx_lock.go:70:14
.\tnx_lock.go:59:2:   flow: {heap} = smutex.rw:
.\tnx_lock.go:59:2:     from smutex.rw.mu (dot of pointer) at .\tnx_lock.go:70:14
.\tnx_lock.go:59:2:     from smutex.rw.mu[smutex.shard % uint(128)] (fixed-array-index-of) at .\tnx_lock.go:70:14
.\tnx_lock.go:59:2:     from smutex.rw.mu[smutex.shard % uint(128)].RWMutex (dot) at .\tnx_lock.go:70:14
.\tnx_lock.go:59:2:     from smutex.rw.mu[smutex.shard % uint(128)].RWMutex (address-of) at .\tnx_lock.go:70:14
.\tnx_lock.go:59:2:     from smutex.rw.mu[smutex.shard % uint(128)].RWMutex.Unlock() (call parameter) at .\tnx_lock.go:70:14
.\tnx_lock.go:58:7: parameter txn leaks to {heap} with derefs=2:
.\tnx_lock.go:58:7:   flow: fill = **txn:
.\tnx_lock.go:58:7:     from txn.owner (dot of pointer) at .\tnx_lock.go:60:13
.\tnx_lock.go:58:7:     from txn.owner.fill (dot of pointer) at .\tnx_lock.go:60:19
.\tnx_lock.go:58:7:     from fill := txn.owner.fill (assign) at .\tnx_lock.go:60:7
.\tnx_lock.go:58:7:   flow: {heap} = fill:
.\tnx_lock.go:58:7:     from fill[start >> 6:end >> 6] (slice) at .\tnx_lock.go:69:16
.\tnx_lock.go:58:7:     from f(chunk, fill[start >> 6:end >> 6]) (call parameter) at .\tnx_lock.go:69:4
.\tnx_lock.go:58:7: leaking param content: txn
.\tnx_lock.go:58:28: f does not escape
.\tnx_lock.go:59:2: moved to heap: lock
.\tnx_lock.go:62:18: func literal does not escape
.\collection.go:358:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:358:7:   flow: atomic.v = *c:
.\collection.go:358:7:     from c.cols (dot of pointer) at .\collection.go:359:11
.\collection.go:358:7:     from atomic.v := c.cols (assign-pair) at .\collection.go:359:21
.\collection.go:358:7:   flow: atomic.vp·3 = atomic.v:
.\collection.go:358:7:     from atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)) (assign) at .\collection.go:359:21
.\collection.go:358:7:   flow: {heap} = atomic.vp·3:
.\collection.go:358:7:     from atomic.vp·3.typ (dot of pointer) at .\collection.go:359:21
.\collection.go:358:7:     from &atomic.vp·3.typ (address-of) at .\collection.go:359:21
.\collection.go:358:7:     from atomic.LoadPointer(&atomic.vp·3.typ) (call parameter) at .\collection.go:359:21
.\collection.go:358:7: leaking param content: c
.\collection.go:358:25: fn does not escape
.\txn.go:425:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:425:7:   flow: deletes = *txn:
.\txn.go:425:7:     from txn.deletes (dot of pointer) at .\txn.go:432:16
.\txn.go:425:7:     from txn.deletes[at:] (slice) at .\txn.go:432:24
.\txn.go:425:7:     from deletes := txn.deletes[at:] (assign) at .\txn.go:432:10
.\txn.go:425:7:   flow: items = deletes:
.\txn.go:425:7:     from c, offset, items := column, at, deletes (assign-pair) at .\txn.go:438:16
.\txn.go:425:7:   flow: {heap} = items:
.\txn.go:425:7:     from c.Column.Delete(offset, items) (call parameter) at .\txn.go:438:16
.\txn.go:437:28: parameter column leaks to {heap} with derefs=1:
.\txn.go:437:28:   flow: c = column:
.\txn.go:437:28:     from c, offset, items := column, at, deletes (assign-pair) at .\txn.go:438:16
.\txn.go:437:28:   flow: {heap} = *c:
.\txn.go:437:28:     from c.Column (dot of pointer) at .\txn.go:438:16
.\txn.go:437:28:     from c.Column.Delete(offset, items) (call parameter) at .\txn.go:438:16
.\txn.go:425:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:425:7:   flow: deletes = *txn:
.\txn.go:425:7:     from txn.deletes (dot of pointer) at .\txn.go:432:16
.\txn.go:425:7:     from txn.deletes[at:] (slice) at .\txn.go:432:24
.\txn.go:425:7:     from deletes := txn.deletes[at:] (assign) at .\txn.go:432:10
.\txn.go:425:7:   flow: items = deletes:
.\txn.go:425:7:     from c, offset, items := column, at, deletes (assign-pair) at .\txn.go:438:16
.\txn.go:425:7:   flow: {heap} = items:
.\txn.go:425:7:     from c.Column.Delete(offset, items) (call parameter) at .\txn.go:438:16
.\txn.go:425:7: leaking param content: txn
.\txn.go:425:45: fill does not escape
.\txn.go:437:28: leaking param content: column
.\txn.go:437:23: func literal does not escape
.\txn.go:448:7: txn does not escape
.\txn.go:448:45: fill does not escape
.\collection.go:378:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:378:7:   flow: atomic.v = *c:
.\collection.go:378:7:     from c.cols (dot of pointer) at .\collection.go:379:11
.\collection.go:378:7:     from atomic.v := c.cols (assign-pair) at .\collection.go:379:21
.\collection.go:378:7:   flow: atomic.vp·3 = atomic.v:
.\collection.go:378:7:     from atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)) (assign) at .\collection.go:379:21
.\collection.go:378:7:   flow: {heap} = atomic.vp·3:
.\collection.go:378:7:     from atomic.vp·3.typ (dot of pointer) at .\collection.go:379:21
.\collection.go:378:7:     from &atomic.vp·3.typ (address-of) at .\collection.go:379:21
.\collection.go:378:7:     from atomic.LoadPointer(&atomic.vp·3.typ) (call parameter) at .\collection.go:379:21
.\collection.go:378:7: leaking param content: c
.\collection.go:378:33: columnName does not escape
.\column.go:144:25: parameter updates leaks to {heap} with derefs=0:
.\column.go:144:25:   flow: {heap} = updates:
.\column.go:144:25:     from c.Column.Update(updates) (call parameter) at .\column.go:146:17
.\column.go:144:7: parameter c leaks to {heap} with derefs=1:
.\column.go:144:7:   flow: {heap} = *c:
.\column.go:144:7:     from c.Column (dot of pointer) at .\column.go:145:3
.\column.go:144:7:     from c.Column.Grow(growUntil) (call parameter) at .\column.go:145:15
.\column.go:144:7: leaking param content: c
.\column.go:144:25: leaking param: updates
.\txn.go:388:7: parameter txn leaks to {heap} with derefs=2:
.\txn.go:388:7:   flow: {heap} = **txn:
.\txn.go:388:7:     from txn.owner (dot of pointer) at .\txn.go:395:25
.\txn.go:388:7:     from txn.owner.cols (dot of pointer) at .\txn.go:395:31
.\txn.go:388:7:     from txn.owner.cols (address-of) at .\txn.go:395:36
.\txn.go:388:7:     from txn.owner.cols.LoadWithIndex(u.Column) (call parameter) at .\txn.go:395:50
.\txn.go:388:7: leaking param content: txn
.\txn.go:355:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:355:7:   flow: {heap} = *txn:
.\txn.go:355:7:     from txn.owner (dot of pointer) at .\txn.go:373:25
.\txn.go:355:7:     from txn.owner.count (dot of pointer) at .\txn.go:373:31
.\txn.go:355:7:     from &txn.owner.count (address-of) at .\txn.go:373:21
.\txn.go:355:7:     from atomic.StoreUint64(&txn.owner.count, uint64(txn.owner.fill.Count())) (call parameter) at .\txn.go:373:20
.\txn.go:355:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:355:7:   flow: {heap} = *txn:
.\txn.go:355:7:     from txn.owner (dot of pointer) at .\txn.go:373:25
.\txn.go:355:7:     from txn.owner.count (dot of pointer) at .\txn.go:373:31
.\txn.go:355:7:     from &txn.owner.count (address-of) at .\txn.go:373:21
.\txn.go:355:7:     from atomic.StoreUint64(&txn.owner.count, uint64(txn.owner.fill.Count())) (call parameter) at .\txn.go:373:20
.\txn.go:355:7: leaking param content: txn
.\txn.go:366:36: fill does not escape
.\txn.go:366:17: func literal does not escape
.\collection.go:247:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:247:7:   flow: {heap} = c:
.\collection.go:247:7:     from aquireTxn(c) (call parameter) at .\collection.go:249:18
.\collection.go:247:7: leaking param: c
.\collection.go:247:28: fn does not escape
.\collection.go:366:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:366:7:   flow: atomic.v = *c:
.\collection.go:366:7:     from c.cols (dot of pointer) at .\collection.go:367:11
.\collection.go:366:7:     from atomic.v := c.cols (assign-pair) at .\collection.go:367:21
.\collection.go:366:7:   flow: atomic.vp·3 = atomic.v:
.\collection.go:366:7:     from atomic.vp·3 = (*atomic.ifaceWords)(unsafe.Pointer(atomic.v)) (assign) at .\collection.go:367:21
.\collection.go:366:7:   flow: {heap} = atomic.vp·3:
.\collection.go:366:7:     from atomic.vp·3.typ (dot of pointer) at .\collection.go:367:21
.\collection.go:366:7:     from &atomic.vp·3.typ (address-of) at .\collection.go:367:21
.\collection.go:366:7:     from atomic.LoadPointer(&atomic.vp·3.typ) (call parameter) at .\collection.go:367:21
.\collection.go:366:7: leaking param content: c
.\collection.go:366:24: columnName does not escape
.\txn.go:69:26: parameter columnName leaks to {heap} with derefs=0:
.\txn.go:69:26:   flow: {heap} = columnName:
.\txn.go:69:26:     from columnCache{...} (struct literal element) at .\txn.go:83:47
.\txn.go:69:26:     from append(txn.columns, columnCache{...}) (call parameter) at .\txn.go:83:22
.\txn.go:69:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:69:7:   flow: {temp} = *txn:
.\txn.go:69:7:     from txn.columns (dot of pointer) at .\txn.go:83:26
.\txn.go:69:7:     from append(txn.columns, columnCache{...}) (call parameter) at .\txn.go:83:22
.\txn.go:69:7:   flow: {heap} = {temp}:
.\txn.go:69:7:     from txn.columns = append(txn.columns, columnCache{...}) (assign) at .\txn.go:83:14
.\txn.go:69:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:69:7:   flow: {temp} = *txn:
.\txn.go:69:7:     from txn.columns (dot of pointer) at .\txn.go:83:26
.\txn.go:69:7:     from append(txn.columns, columnCache{...}) (call parameter) at .\txn.go:83:22
.\txn.go:69:7:   flow: {heap} = {temp}:
.\txn.go:69:7:     from txn.columns = append(txn.columns, columnCache{...}) (assign) at .\txn.go:83:14
.\txn.go:69:7: parameter txn leaks to ~r1 with derefs=2:
.\txn.go:69:7:   flow: {temp} = *txn:
.\txn.go:69:7:     from txn.columns (dot of pointer) at .\txn.go:70:23
.\txn.go:69:7:   flow: v = *{temp}:
.\txn.go:69:7:     from for loop (range-deref) at .\txn.go:70:14
.\txn.go:69:7:   flow: ~r1 = v:
.\txn.go:69:7:     from v.col (dot) at .\txn.go:72:12
.\txn.go:69:7:     from return v.col, true (return) at .\txn.go:72:4
.\txn.go:69:7: leaking param content: txn
.\txn.go:69:26: leaking param: columnName
.\txn_cursor.go:34:17: make([]commit.Update, 0, 64) escapes to heap:
.\txn_cursor.go:34:17:   flow: {heap} = &{storage for make([]commit.Update, 0, 64)}:
.\txn_cursor.go:34:17:     from make([]commit.Update, 0, 64) (spill) at .\txn_cursor.go:34:17
.\txn_cursor.go:34:17:     from commit.Updates{...} (struct literal element) at .\txn_cursor.go:31:51
.\txn_cursor.go:34:17:     from append(txn.updates, commit.Updates{...}) (call parameter) at .\txn_cursor.go:31:23
.\txn_cursor.go:35:17: make([]int, 0, 64) escapes to heap:
.\txn_cursor.go:35:17:   flow: {heap} = &{storage for make([]int, 0, 64)}:
.\txn_cursor.go:35:17:     from make([]int, 0, 64) (spill) at .\txn_cursor.go:35:17
.\txn_cursor.go:35:17:     from commit.Updates{...} (struct literal element) at .\txn_cursor.go:31:51
.\txn_cursor.go:35:17:     from append(txn.updates, commit.Updates{...}) (call parameter) at .\txn_cursor.go:31:23
.\txn_cursor.go:16:31: columnName escapes to heap:
.\txn_cursor.go:16:31:   flow: {storage for ... argument} = &{storage for columnName}:
.\txn_cursor.go:16:31:     from columnName (spill) at .\txn_cursor.go:16:31
.\txn_cursor.go:16:31:     from ... argument (slice-literal-element) at .\txn_cursor.go:16:30
.\txn_cursor.go:16:31:   flow: {heap} = {storage for ... argument}:
.\txn_cursor.go:16:31:     from ... argument (spill) at .\txn_cursor.go:16:30
.\txn_cursor.go:16:31:     from fmt.Errorf("column: specified column '%v' does not exist", ... argument...) (call parameter) at .\txn_cursor.go:16:30
.\txn_cursor.go:13:27: parameter columnName leaks to {heap} with derefs=0:
.\txn_cursor.go:13:27:   flow: {heap} = columnName:
.\txn_cursor.go:13:27:     from txn.columnAt(columnName) (call parameter) at .\txn_cursor.go:14:23
.\txn_cursor.go:13:7: parameter txn leaks to {heap} with derefs=1:
.\txn_cursor.go:13:7:   flow: {heap} = *txn:
.\txn_cursor.go:13:7:     from txn.columnAt(columnName) (call parameter) at .\txn_cursor.go:14:23
.\txn_cursor.go:13:27: parameter columnName leaks to {storage for columnName} with derefs=0:
.\txn_cursor.go:13:27:   flow: {storage for columnName} = columnName:
.\txn_cursor.go:13:27:     from columnName (interface-converted) at .\txn_cursor.go:16:31
.\txn_cursor.go:13:7: parameter txn leaks to ~r1 with derefs=0:
.\txn_cursor.go:13:7:   flow: ~r1 = txn:
.\txn_cursor.go:13:7:     from Selector{...} (struct literal element) at .\txn_cursor.go:43:21
.\txn_cursor.go:13:7:     from Cursor{...} (struct literal element) at .\txn_cursor.go:40:15
.\txn_cursor.go:13:7:     from return Cursor{...}, nil (return) at .\txn_cursor.go:40:2
.\txn_cursor.go:13:7: leaking param content: txn
.\txn_cursor.go:13:7: leaking param: txn to result ~r1 level=0
.\txn_cursor.go:13:27: leaking param: columnName
.\txn_cursor.go:16:30: ... argument does not escape
.\txn_cursor.go:16:31: columnName escapes to heap
.\txn_cursor.go:34:17: make([]commit.Update, 0, 64) escapes to heap
.\txn_cursor.go:35:17: make([]int, 0, 64) escapes to heap
.\tnx_lock.go:23:2: lock escapes to heap:
.\tnx_lock.go:23:2:   flow: {heap} = &lock:
.\tnx_lock.go:23:2:     from lock (address-of) at .\tnx_lock.go:32:7
.\tnx_lock.go:23:2:     from lock.RLock(uint(chunk)) (call parameter) at .\tnx_lock.go:32:13
.\tnx_lock.go:23:2: lock escapes to heap:
.\tnx_lock.go:23:2:   flow: {heap} = &lock:
.\tnx_lock.go:23:2:     from lock (address-of) at .\tnx_lock.go:34:7
.\tnx_lock.go:23:2:     from lock.RUnlock(uint(chunk)) (call parameter) at .\tnx_lock.go:34:15
.\tnx_lock.go:21:7: parameter txn leaks to {heap} with derefs=1:
.\tnx_lock.go:21:7:   flow: fill = *txn:
.\tnx_lock.go:21:7:     from txn.index (dot of pointer) at .\tnx_lock.go:27:14
.\tnx_lock.go:21:7:     from txn.index[at:] (slice) at .\tnx_lock.go:27:20
.\tnx_lock.go:21:7:     from fill := txn.index[at:] (assign) at .\tnx_lock.go:27:8
.\tnx_lock.go:21:7:   flow: {heap} = fill:
.\tnx_lock.go:21:7:     from f(chunk << chunkShift, fill) (call parameter) at .\tnx_lock.go:33:4
.\tnx_lock.go:21:7: leaking param content: txn
.\tnx_lock.go:21:27: f does not escape
.\tnx_lock.go:23:2: moved to heap: lock
.\txn.go:316:7: parameter txn leaks to {heap} with derefs=0:
.\txn.go:316:7:   flow: {temp} = txn:
.\txn.go:316:7:     from txn.cursorFor(column) (call parameter) at .\txn.go:317:27
.\txn.go:316:7:   flow: cur = {temp}:
.\txn.go:316:7:   flow: {heap} = cur:
.\txn.go:316:7:     from fn(cur) (call parameter) at .\txn.go:325:6
.\txn.go:316:7: parameter txn leaks to {heap} with derefs=0:
.\txn.go:316:7:   flow: {temp} = txn:
.\txn.go:316:7:     from txn.cursorFor(column) (call parameter) at .\txn.go:317:27
.\txn.go:316:7:   flow: cur = {temp}:
.\txn.go:316:7:   flow: {heap} = cur:
.\txn.go:316:7:     from fn(cur) (call parameter) at .\txn.go:325:6
.\txn.go:316:23: parameter column leaks to {heap} with derefs=0:
.\txn.go:316:23:   flow: {heap} = column:
.\txn.go:316:23:     from txn.cursorFor(column) (call parameter) at .\txn.go:317:27
.\txn.go:316:7: leaking param: txn
.\txn.go:316:23: leaking param: column
.\txn.go:316:38: fn does not escape
.\txn.go:322:36: index does not escape
.\txn.go:322:16: func literal does not escape
.\txn.go:323:15: func literal does not escape
.\tnx_lock.go:42:2: lock escapes to heap:
.\tnx_lock.go:42:2:   flow: {heap} = &lock:
.\tnx_lock.go:42:2:     from lock (address-of) at .\tnx_lock.go:52:7
.\tnx_lock.go:42:2:     from lock.RLock(uint(chunk)) (call parameter) at .\tnx_lock.go:52:13
.\tnx_lock.go:42:2: lock escapes to heap:
.\tnx_lock.go:42:2:   flow: {heap} = &lock:
.\tnx_lock.go:42:2:     from lock (address-of) at .\tnx_lock.go:54:7
.\tnx_lock.go:42:2:     from lock.RUnlock(uint(chunk)) (call parameter) at .\tnx_lock.go:54:15
.\tnx_lock.go:40:31: parameter other leaks to {heap} with derefs=0:
.\tnx_lock.go:40:31:   flow: src = other:
.\tnx_lock.go:40:31:     from other[at:] (slice) at .\tnx_lock.go:46:36
.\tnx_lock.go:40:31:     from dst, src := txn.index[at:], other[at:] (assign-pair) at .\tnx_lock.go:46:12
.\tnx_lock.go:40:31:   flow: {heap} = src:
.\tnx_lock.go:40:31:     from f(dst, src) (call parameter) at .\tnx_lock.go:53:4
.\tnx_lock.go:40:7: parameter txn leaks to {heap} with derefs=1:
.\tnx_lock.go:40:7:   flow: dst = *txn:
.\tnx_lock.go:40:7:     from txn.index (dot of pointer) at .\tnx_lock.go:46:18
.\tnx_lock.go:40:7:     from txn.index[at:] (slice) at .\tnx_lock.go:46:24
.\tnx_lock.go:40:7:     from dst, src := txn.index[at:], other[at:] (assign-pair) at .\tnx_lock.go:46:12
.\tnx_lock.go:40:7:   flow: {heap} = dst:
.\tnx_lock.go:40:7:     from f(dst, src) (call parameter) at .\tnx_lock.go:53:4
.\tnx_lock.go:40:7: leaking param content: txn
.\tnx_lock.go:40:31: leaking param: other
.\tnx_lock.go:40:52: f does not escape
.\tnx_lock.go:42:2: moved to heap: lock
.\txn.go:91:22: parameter columns leaks to {heap} with derefs=1:
.\txn.go:91:22:   flow: {temp} = columns:
.\txn.go:91:22:   flow: columnName = *{temp}:
.\txn.go:91:22:     from for loop (range-deref) at .\txn.go:92:23
.\txn.go:91:22:   flow: {heap} = columnName:
.\txn.go:91:22:     from txn.columnAt(columnName) (call parameter) at .\txn.go:93:29
.\txn.go:91:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:91:7:   flow: {heap} = *txn:
.\txn.go:91:7:     from txn.columnAt(columnName) (call parameter) at .\txn.go:93:29
.\txn.go:91:7: parameter txn leaks to ~r1 with derefs=0:
.\txn.go:91:7:   flow: ~r1 = txn:
.\txn.go:91:7:     from return txn (return) at .\txn.go:101:2
.\txn.go:91:7: leaking param content: txn
.\txn.go:91:7: leaking param: txn to result ~r1 level=0
.\txn.go:91:22: leaking param content: columns
.\txn.go:94:48: dst does not escape
.\txn.go:94:53: src does not escape
.\txn.go:94:43: func literal does not escape
.\txn_cursor.go:145:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:145:7:   flow: c = *cur:
.\txn_cursor.go:145:7:     from cur.column (dot of pointer) at .\txn_cursor.go:146:14
.\txn_cursor.go:145:7:     from c, idx := cur.column, cur.Selector.idx (assign-pair) at .\txn_cursor.go:146:27
.\txn_cursor.go:145:7:   flow: n = *c:
.\txn_cursor.go:145:7:     from c.Column (dot of pointer) at .\txn_cursor.go:146:27
.\txn_cursor.go:145:7:     from c.Column.(Numeric) (dot) at .\txn_cursor.go:146:27
.\txn_cursor.go:145:7:     from n, contains = c.Column.(Numeric) (assign-pair-dot-type) at .\txn_cursor.go:146:27
.\txn_cursor.go:145:7:   flow: {heap} = n:
.\txn_cursor.go:145:7:     from n.LoadInt64(idx) (call parameter) at .\txn_cursor.go:146:27
.\txn_cursor.go:145:7: leaking param content: cur
.\txn_cursor.go:165:7: cur does not escape
.\collection.go:283:60: parameter v leaks to {heap} with derefs=1:
.\collection.go:283:60:   flow: {heap} = *v:
.\collection.go:283:60:     from v (address-of) at .\collection.go:284:24
.\collection.go:283:60:     from v.Int() (call parameter) at .\collection.go:284:28
.\collection.go:282:17: parameter txn leaks to {heap} with derefs=0:
.\collection.go:282:17:   flow: {temp} = txn:
.\collection.go:282:17:     from txn.With(... argument...) (call parameter) at .\collection.go:283:20
.\collection.go:282:17:   flow: {heap} = {temp}:
.\collection.go:282:17:     from txn.With(... argument...).Range(expireColumn, func literal) (call parameter) at .\collection.go:283:40
.\collection.go:273:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:273:7:   flow: {heap} = c:
.\collection.go:273:7:     from c.Query(func literal) (call parameter) at .\collection.go:282:11
.\collection.go:273:29: parameter ctx leaks to {heap} with derefs=0:
.\collection.go:273:29:   flow: {heap} = ctx:
.\collection.go:273:29:     from ctx.Done() (call parameter) at .\collection.go:277:18
.\collection.go:273:7: leaking param: c
.\collection.go:273:29: leaking param: ctx
.\collection.go:282:17: leaking param: txn
.\collection.go:283:60: leaking param content: v
.\collection.go:282:12: func literal does not escape
.\collection.go:283:20: ... argument does not escape
.\collection.go:283:55: func literal does not escape
.\collection.go:70:22: make([]columnEntry, 0, capacity) escapes to heap:
.\collection.go:70:22:   flow: {heap} = &{storage for make([]columnEntry, 0, capacity)}:
.\collection.go:70:22:     from make([]columnEntry, 0, capacity) (spill) at .\collection.go:70:22
.\collection.go:70:22:     from data.cols.Store(make([]columnEntry, 0, capacity)) (call parameter) at .\collection.go:70:22
.\collection.go:70:22: make([]columnEntry, 0, capacity) escapes to heap:
.\collection.go:70:22:   flow: {heap} = &{storage for make([]columnEntry, 0, capacity)}:
.\collection.go:70:22:     from make([]columnEntry, 0, capacity) (non-constant size) at .\collection.go:70:22
.\collection.go:70:22: make([]columnEntry, 0, capacity) escapes to heap:
.\collection.go:70:22:   flow: {storage for make([]columnEntry, 0, capacity)} = &{storage for make([]columnEntry, 0, capacity)}:
.\collection.go:70:22:     from make([]columnEntry, 0, capacity) (spill) at .\collection.go:70:22
.\collection.go:70:22:     from make([]columnEntry, 0, capacity) (interface-converted) at .\collection.go:70:22
.\collection.go:72:15: make(bitmap.Bitmap, 0, options.Capacity >> 6) escapes to heap:
.\collection.go:72:15:   flow: {heap} = &{storage for make(bitmap.Bitmap, 0, options.Capacity >> 6)}:
.\collection.go:72:15:     from make(bitmap.Bitmap, 0, options.Capacity >> 6) (non-constant size) at .\collection.go:72:15
.\collection.go:69:11: &Collection{...} escapes to heap:
.\collection.go:69:11:   flow: store = &{storage for &Collection{...}}:
.\collection.go:69:11:     from &Collection{...} (spill) at .\collection.go:69:11
.\collection.go:69:11:     from store := &Collection{...} (assign) at .\collection.go:69:8
.\collection.go:69:11:   flow: {heap} = store:
.\collection.go:69:11:     from store.vacuum(ctx, options.Vacuum) (call parameter) at .\collection.go:79:17
.\collection.go:70:22: &atomic.Value{} escapes to heap:
.\collection.go:70:22:   flow: data = &{storage for &atomic.Value{}}:
.\collection.go:70:22:     from &atomic.Value{} (spill) at .\collection.go:70:22
.\collection.go:70:22:     from columns{...} (struct literal element) at .\collection.go:70:22
.\collection.go:70:22:     from data := columns{...} (assign) at .\collection.go:70:22
.\collection.go:70:22:   flow: {heap} = data:
.\collection.go:70:22:     from data.cols (dot) at .\collection.go:70:22
.\collection.go:70:22:     from data.cols.Store(make([]columnEntry, 0, capacity)) (call parameter) at .\collection.go:70:22
.\collection.go:47:20: parameter opts leaks to {storage for &Collection{...}} with derefs=1:
.\collection.go:47:20:   flow: {temp} = opts:
.\collection.go:47:20:   flow: o = *{temp}:
.\collection.go:47:20:     from for loop (range-deref) at .\collection.go:55:14
.\collection.go:47:20:   flow: options = o:
.\collection.go:47:20:     from o.Writer (dot) at .\collection.go:63:22
.\collection.go:47:20:     from options.Writer = o.Writer (assign) at .\collection.go:63:19
.\collection.go:47:20:   flow: {storage for &Collection{...}} = options:
.\collection.go:47:20:     from options.Writer (dot) at .\collection.go:73:18
.\collection.go:47:20:     from Collection{...} (struct literal element) at .\collection.go:69:22
.\collection.go:47:20: leaking param content: opts
.\collection.go:69:11: &Collection{...} escapes to heap
.\collection.go:70:22: &atomic.Value{} escapes to heap
.\collection.go:70:22: make([]columnEntry, 0, capacity) escapes to heap
.\collection.go:70:22: make([]columnEntry, 0, capacity) escapes to heap
.\collection.go:72:15: make(bitmap.Bitmap, 0, options.Capacity >> 6) escapes to heap
.\collection.go:93:7: c does not escape
.\collection.go:84:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:84:7:   flow: {heap} = c:
.\collection.go:84:7:     from c.lock (dot of pointer) at .\collection.go:85:3
.\collection.go:84:7:     from c.lock (address-of) at .\collection.go:85:8
.\collection.go:84:7:     from c.lock.Lock() (call parameter) at .\collection.go:85:13
.\collection.go:84:7: leaking param: c
.\txn_cursor.go:242:17: []int{...} escapes to heap:
.\txn_cursor.go:242:17:   flow: {heap} = &{storage for []int{...}}:
.\txn_cursor.go:242:17:     from []int{...} (spill) at .\txn_cursor.go:242:17
.\txn_cursor.go:242:17:     from commit.Updates{...} (struct literal element) at .\txn_cursor.go:239:58
.\txn_cursor.go:242:17:     from append(cur.Selector.txn.updates, commit.Updates{...}) (call parameter) at .\txn_cursor.go:239:26
.\txn_cursor.go:224:34: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:224:34:   flow: {heap} = column:
.\txn_cursor.go:224:34:     from commit.Updates{...} (struct literal element) at .\txn_cursor.go:239:58
.\txn_cursor.go:224:34:     from append(cur.Selector.txn.updates, commit.Updates{...}) (call parameter) at .\txn_cursor.go:239:26
.\txn_cursor.go:224:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:224:7:   flow: {temp} = **cur:
.\txn_cursor.go:224:7:     from cur.Selector (dot of pointer) at .\txn_cursor.go:239:30
.\txn_cursor.go:224:7:     from cur.Selector.txn (dot) at .\txn_cursor.go:239:30
.\txn_cursor.go:224:7:     from cur.Selector.txn.updates (dot of pointer) at .\txn_cursor.go:239:34
.\txn_cursor.go:224:7:     from append(cur.Selector.txn.updates, commit.Updates{...}) (call parameter) at .\txn_cursor.go:239:26
.\txn_cursor.go:224:7:   flow: {heap} = {temp}:
.\txn_cursor.go:224:7:     from cur.Selector.txn.updates = append(cur.Selector.txn.updates, commit.Updates{...}) (assign) at .\txn_cursor.go:239:18
.\txn_cursor.go:224:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:224:7:   flow: {temp} = **cur:
.\txn_cursor.go:224:7:     from cur.Selector (dot of pointer) at .\txn_cursor.go:239:30
.\txn_cursor.go:224:7:     from cur.Selector.txn (dot) at .\txn_cursor.go:239:30
.\txn_cursor.go:224:7:     from cur.Selector.txn.updates (dot of pointer) at .\txn_cursor.go:239:34
.\txn_cursor.go:224:7:     from append(cur.Selector.txn.updates, commit.Updates{...}) (call parameter) at .\txn_cursor.go:239:26
.\txn_cursor.go:224:7:   flow: {heap} = {temp}:
.\txn_cursor.go:224:7:     from cur.Selector.txn.updates = append(cur.Selector.txn.updates, commit.Updates{...}) (assign) at .\txn_cursor.go:239:18
.\txn_cursor.go:224:7: leaking param content: cur
.\txn_cursor.go:224:34: leaking param: column
.\txn_cursor.go:242:17: []int{...} escapes to heap
.\txn_cursor.go:194:44: parameter value leaks to {heap} with derefs=0:
.\txn_cursor.go:194:44:   flow: {heap} = value:
.\txn_cursor.go:194:44:     from commit.Update{...} (struct literal element) at .\txn_cursor.go:196:97
.\txn_cursor.go:194:44:     from append(cur.Selector.txn.updates[columnIndex].Update, commit.Update{...}) (call parameter) at .\txn_cursor.go:196:46
.\txn_cursor.go:194:29: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:194:29:   flow: {heap} = column:
.\txn_cursor.go:194:29:     from cur.updateChunkAt(column, cur.Selector.idx) (call parameter) at .\txn_cursor.go:195:34
.\txn_cursor.go:194:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:194:7:   flow: {heap} = **cur:
.\txn_cursor.go:194:7:     from cur.updateChunkAt(column, cur.Selector.idx) (call parameter) at .\txn_cursor.go:195:34
.\txn_cursor.go:194:7: leaking param content: cur
.\txn_cursor.go:194:29: leaking param: column
.\txn_cursor.go:194:44: leaking param: value
.\txn.go:272:16: expireAt escapes to heap:
.\txn.go:272:16:   flow: {heap} = &{storage for expireAt}:
.\txn.go:272:16:     from expireAt (spill) at .\txn.go:272:16
.\txn.go:272:16:     from slot.UpdateAt(expireColumn, expireAt) (call parameter) at .\txn.go:272:16
.\txn.go:253:24: parameter object leaks to {heap} with derefs=1:
.\txn.go:253:24:   flow: {temp} = object:
.\txn.go:253:24:   flow: v = *{temp}:
.\txn.go:253:24:     from for loop (range-deref) at .\txn.go:264:14
.\txn.go:253:24:   flow: {heap} = v:
.\txn.go:253:24:     from slot.UpdateAt(k, v) (call parameter) at .\txn.go:266:17
.\txn.go:253:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:253:7:   flow: {heap} = *txn:
.\txn.go:253:7:     from txn.owner (dot of pointer) at .\txn.go:256:12
.\txn.go:253:7:     from txn.owner.next() (call parameter) at .\txn.go:256:23
.\txn.go:253:7: leaking param content: txn
.\txn.go:253:24: leaking param content: object
.\txn.go:272:16: expireAt escapes to heap
.\collection.go:115:29: parameter obj leaks to {heap} with derefs=1:
.\collection.go:115:29:   flow: object = obj:
.\collection.go:115:29:     from txn, object := txn, obj (assign-pair) at .\collection.go:117:21
.\collection.go:115:29:   flow: {heap} = *object:
.\collection.go:115:29:     from txn.insert(object, 0) (call parameter) at .\collection.go:117:21
.\collection.go:116:15: parameter txn leaks to {heap} with derefs=1:
.\collection.go:116:15:   flow: txn = txn:
.\collection.go:116:15:     from txn, object := txn, obj (assign-pair) at .\collection.go:117:21
.\collection.go:116:15:   flow: {heap} = *txn:
.\collection.go:116:15:     from txn.insert(object, 0) (call parameter) at .\collection.go:117:21
.\collection.go:115:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:115:7:   flow: {heap} = c:
.\collection.go:115:7:     from c.Query(func literal) (call parameter) at .\collection.go:116:9
.\collection.go:115:7: leaking param: c
.\collection.go:115:29: leaking param content: obj
.\collection.go:116:15: leaking param content: txn
.\collection.go:116:10: func literal does not escape
.\txn.go:247:31: parameter object leaks to {heap} with derefs=1:
.\txn.go:247:31:   flow: {heap} = *object:
.\txn.go:247:31:     from txn.insert(object, int64(~R0)) (call parameter) at .\txn.go:248:19
.\txn.go:247:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:247:7:   flow: {heap} = *txn:
.\txn.go:247:7:     from txn.insert(object, int64(~R0)) (call parameter) at .\txn.go:248:19
.\txn.go:247:7: leaking param content: txn
.\txn.go:247:31: leaking param content: object
.\collection.go:125:36: parameter obj leaks to {heap} with derefs=1:
.\collection.go:125:36:   flow: {heap} = *obj:
.\collection.go:125:36:     from txn.InsertWithTTL(obj, ttl) (call parameter) at .\collection.go:127:28
.\collection.go:126:15: parameter txn leaks to {heap} with derefs=1:
.\collection.go:126:15:   flow: {heap} = *txn:
.\collection.go:126:15:     from txn.InsertWithTTL(obj, ttl) (call parameter) at .\collection.go:127:28
.\collection.go:125:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:125:7:   flow: {heap} = c:
.\collection.go:125:7:     from c.Query(func literal) (call parameter) at .\collection.go:126:9
.\collection.go:125:7: leaking param: c
.\collection.go:125:36: leaking param content: obj
.\collection.go:126:15: leaking param content: txn
.\collection.go:126:10: func literal does not escape
.\txn_cursor.go:214:7: parameter cur leaks to {heap} with derefs=3:
.\txn_cursor.go:214:7:   flow: {heap} = ***cur:
.\txn_cursor.go:214:7:     from cur.Selector (dot of pointer) at .\txn_cursor.go:219:51
.\txn_cursor.go:214:7:     from cur.Selector.txn (dot) at .\txn_cursor.go:219:51
.\txn_cursor.go:214:7:     from cur.Selector.txn.updates (dot of pointer) at .\txn_cursor.go:219:55
.\txn_cursor.go:214:7:     from cur.Selector.txn.updates[cur.update] (dot of pointer) at .\txn_cursor.go:219:63
.\txn_cursor.go:214:7:     from cur.Selector.txn.updates[cur.update].Offsets (dot) at .\txn_cursor.go:219:75
.\txn_cursor.go:214:7:     from append(cur.Selector.txn.updates[cur.update].Offsets, len(cur.Selector.txn.updates[cur.update].Update)) (call parameter) at .\txn_cursor.go:219:47
.\txn_cursor.go:214:7:     from cur.Selector.txn.updates[cur.update].Offsets = append(cur.Selector.txn.updates[cur.update].Offsets, len(cur.Selector.txn.updates[cur.update].Update)) (assign) at .\txn_cursor.go:219:39
.\txn_cursor.go:214:7: leaking param content: cur
.\txn_cursor.go:172:27: parameter value leaks to {heap} with derefs=0:
.\txn_cursor.go:172:27:   flow: {heap} = value:
.\txn_cursor.go:172:27:     from commit.Update{...} (struct literal element) at .\txn_cursor.go:174:95
.\txn_cursor.go:172:27:     from append(cur.Selector.txn.updates[cur.update].Update, commit.Update{...}) (call parameter) at .\txn_cursor.go:174:45
.\txn_cursor.go:172:7: parameter cur leaks to {heap} with derefs=3:
.\txn_cursor.go:172:7:   flow: {heap} = ***cur:
.\txn_cursor.go:172:7:     from cur.updateChunk(cur.Selector.idx) (call parameter) at .\txn_cursor.go:173:17
.\txn_cursor.go:172:7: leaking param content: cur
.\txn_cursor.go:172:27: leaking param: value
.\collection.go:135:62: parameter value leaks to {heap} with derefs=0:
.\collection.go:135:62:   flow: {heap} = value:
.\collection.go:135:62:     from cursor.Update(value) (call parameter) at .\collection.go:139:17
.\collection.go:135:43: parameter columnName leaks to {heap} with derefs=0:
.\collection.go:135:43:   flow: {heap} = columnName:
.\collection.go:135:43:     from txn.cursorFor(columnName) (call parameter) at .\collection.go:137:34
.\collection.go:136:15: parameter txn leaks to {heap} with derefs=1:
.\collection.go:136:15:   flow: {temp} = txn:
.\collection.go:136:15:     from txn.cursorFor(columnName) (call parameter) at .\collection.go:137:34
.\collection.go:136:15:   flow: {heap} = *{temp}:
.\collection.go:135:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:135:7:   flow: {heap} = c:
.\collection.go:135:7:     from c.Query(func literal) (call parameter) at .\collection.go:136:9
.\collection.go:135:7: leaking param: c
.\collection.go:135:43: leaking param: columnName
.\collection.go:135:62: leaking param: value
.\collection.go:136:15: leaking param content: txn
.\collection.go:136:10: func literal does not escape
.\txn.go:228:7: txn does not escape
.\collection.go:147:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:147:7:   flow: {heap} = c:
.\collection.go:147:7:     from c.Query(func literal) (call parameter) at .\collection.go:148:9
.\collection.go:147:7: leaking param: c
.\collection.go:148:15: txn does not escape
.\collection.go:148:10: func literal does not escape
.\collection.go:156:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:156:7:   flow: {heap} = c:
.\collection.go:156:7:     from c.count (dot of pointer) at .\collection.go:157:33
.\collection.go:156:7:     from &c.count (address-of) at .\collection.go:157:31
.\collection.go:156:7:     from atomic.LoadUint64(&c.count) (call parameter) at .\collection.go:157:30
.\collection.go:156:7: leaking param: c
.\column.go:111:17: &columnAny{...} escapes to heap:
.\column.go:111:17:   flow: ~R0 = &{storage for &columnAny{...}}:
.\column.go:111:17:     from &columnAny{...} (spill) at .\column.go:111:17
.\column.go:111:17:     from &columnAny{...} (interface-converted) at .\column.go:111:17
.\column.go:111:17:     from ~R0 = <N> (assign-pair) at .\column.go:111:17
.\column.go:111:17:   flow: ~r1 = ~R0:
.\column.go:111:17:     from return Column(~R0) (return) at .\column.go:111:3
.\column.go:109:19: &columnBool{...} escapes to heap:
.\column.go:109:19:   flow: ~R0 = &{storage for &columnBool{...}}:
.\column.go:109:19:     from &columnBool{...} (spill) at .\column.go:109:19
.\column.go:109:19:     from &columnBool{...} (interface-converted) at .\column.go:109:19
.\column.go:109:19:     from ~R0 = <N> (assign-pair) at .\column.go:109:19
.\column.go:109:19:   flow: ~r1 = ~R0:
.\column.go:109:19:     from return Column(~R0) (return) at .\column.go:109:3
.\column.go:107:21: &columnUint64{...} escapes to heap:
.\column.go:107:21:   flow: ~R0 = &{storage for &columnUint64{...}}:
.\column.go:107:21:     from &columnUint64{...} (spill) at .\column.go:107:21
.\column.go:107:21:     from &columnUint64{...} (interface-converted) at .\column.go:107:21
.\column.go:107:21:     from ~R0 = <N> (assign-pair) at .\column.go:107:21
.\column.go:107:21:   flow: ~r1 = ~R0:
.\column.go:107:21:     from return Column(~R0) (return) at .\column.go:107:3
.\column.go:105:21: &columnUint32{...} escapes to heap:
.\column.go:105:21:   flow: ~R0 = &{storage for &columnUint32{...}}:
.\column.go:105:21:     from &columnUint32{...} (spill) at .\column.go:105:21
.\column.go:105:21:     from &columnUint32{...} (interface-converted) at .\column.go:105:21
.\column.go:105:21:     from ~R0 = <N> (assign-pair) at .\column.go:105:21
.\column.go:105:21:   flow: ~r1 = ~R0:
.\column.go:105:21:     from return Column(~R0) (return) at .\column.go:105:3
.\column.go:103:21: &columnUint16{...} escapes to heap:
.\column.go:103:21:   flow: ~R0 = &{storage for &columnUint16{...}}:
.\column.go:103:21:     from &columnUint16{...} (spill) at .\column.go:103:21
.\column.go:103:21:     from &columnUint16{...} (interface-converted) at .\column.go:103:21
.\column.go:103:21:     from ~R0 = <N> (assign-pair) at .\column.go:103:21
.\column.go:103:21:   flow: ~r1 = ~R0:
.\column.go:103:21:     from return Column(~R0) (return) at .\column.go:103:3
.\column.go:101:19: &columnUint{...} escapes to heap:
.\column.go:101:19:   flow: ~R0 = &{storage for &columnUint{...}}:
.\column.go:101:19:     from &columnUint{...} (spill) at .\column.go:101:19
.\column.go:101:19:     from &columnUint{...} (interface-converted) at .\column.go:101:19
.\column.go:101:19:     from ~R0 = <N> (assign-pair) at .\column.go:101:19
.\column.go:101:19:   flow: ~r1 = ~R0:
.\column.go:101:19:     from return Column(~R0) (return) at .\column.go:101:3
.\column.go:99:20: &columnInt64{...} escapes to heap:
.\column.go:99:20:   flow: ~R0 = &{storage for &columnInt64{...}}:
.\column.go:99:20:     from &columnInt64{...} (spill) at .\column.go:99:20
.\column.go:99:20:     from &columnInt64{...} (interface-converted) at .\column.go:99:20
.\column.go:99:20:     from ~R0 = <N> (assign-pair) at .\column.go:99:20
.\column.go:99:20:   flow: ~r1 = ~R0:
.\column.go:99:20:     from return Column(~R0) (return) at .\column.go:99:3
.\column.go:97:20: &columnInt32{...} escapes to heap:
.\column.go:97:20:   flow: ~R0 = &{storage for &columnInt32{...}}:
.\column.go:97:20:     from &columnInt32{...} (spill) at .\column.go:97:20
.\column.go:97:20:     from &columnInt32{...} (interface-converted) at .\column.go:97:20
.\column.go:97:20:     from ~R0 = <N> (assign-pair) at .\column.go:97:20
.\column.go:97:20:   flow: ~r1 = ~R0:
.\column.go:97:20:     from return Column(~R0) (return) at .\column.go:97:3
.\column.go:95:20: &columnInt16{...} escapes to heap:
.\column.go:95:20:   flow: ~R0 = &{storage for &columnInt16{...}}:
.\column.go:95:20:     from &columnInt16{...} (spill) at .\column.go:95:20
.\column.go:95:20:     from &columnInt16{...} (interface-converted) at .\column.go:95:20
.\column.go:95:20:     from ~R0 = <N> (assign-pair) at .\column.go:95:20
.\column.go:95:20:   flow: ~r1 = ~R0:
.\column.go:95:20:     from return Column(~R0) (return) at .\column.go:95:3
.\column.go:93:18: &columnInt{...} escapes to heap:
.\column.go:93:18:   flow: ~R0 = &{storage for &columnInt{...}}:
.\column.go:93:18:     from &columnInt{...} (spill) at .\column.go:93:18
.\column.go:93:18:     from &columnInt{...} (interface-converted) at .\column.go:93:18
.\column.go:93:18:     from ~R0 = <N> (assign-pair) at .\column.go:93:18
.\column.go:93:18:   flow: ~r1 = ~R0:
.\column.go:93:18:     from return Column(~R0) (return) at .\column.go:93:3
.\column.go:91:22: &columnFloat64{...} escapes to heap:
.\column.go:91:22:   flow: ~R0 = &{storage for &columnFloat64{...}}:
.\column.go:91:22:     from &columnFloat64{...} (spill) at .\column.go:91:22
.\column.go:91:22:     from &columnFloat64{...} (interface-converted) at .\column.go:91:22
.\column.go:91:22:     from ~R0 = <N> (assign-pair) at .\column.go:91:22
.\column.go:91:22:   flow: ~r1 = ~R0:
.\column.go:91:22:     from return Column(~R0) (return) at .\column.go:91:3
.\column.go:89:22: &columnFloat32{...} escapes to heap:
.\column.go:89:22:   flow: ~R0 = &{storage for &columnFloat32{...}}:
.\column.go:89:22:     from &columnFloat32{...} (spill) at .\column.go:89:22
.\column.go:89:22:     from &columnFloat32{...} (interface-converted) at .\column.go:89:22
.\column.go:89:22:     from ~R0 = <N> (assign-pair) at .\column.go:89:22
.\column.go:89:22:   flow: ~r1 = ~R0:
.\column.go:89:22:     from return Column(~R0) (return) at .\column.go:89:3
.\column.go:89:22: make([]float32, 0, 64) escapes to heap:
.\column.go:89:22:   flow: {storage for &columnFloat32{...}} = &{storage for make([]float32, 0, 64)}:
.\column.go:89:22:     from make([]float32, 0, 64) (spill) at .\column.go:89:22
.\column.go:89:22:     from columnFloat32{...} (struct literal element) at .\column.go:89:22
.\column.go:89:22: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:89:22:   flow: {storage for &columnFloat32{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:89:22:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:89:22
.\column.go:89:22:     from columnFloat32{...} (struct literal element) at .\column.go:89:22
.\column.go:91:22: make([]float64, 0, 64) escapes to heap:
.\column.go:91:22:   flow: {storage for &columnFloat64{...}} = &{storage for make([]float64, 0, 64)}:
.\column.go:91:22:     from make([]float64, 0, 64) (spill) at .\column.go:91:22
.\column.go:91:22:     from columnFloat64{...} (struct literal element) at .\column.go:91:22
.\column.go:91:22: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:91:22:   flow: {storage for &columnFloat64{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:91:22:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:91:22
.\column.go:91:22:     from columnFloat64{...} (struct literal element) at .\column.go:91:22
.\column.go:93:18: make([]int, 0, 64) escapes to heap:
.\column.go:93:18:   flow: {storage for &columnInt{...}} = &{storage for make([]int, 0, 64)}:
.\column.go:93:18:     from make([]int, 0, 64) (spill) at .\column.go:93:18
.\column.go:93:18:     from columnInt{...} (struct literal element) at .\column.go:93:18
.\column.go:93:18: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:93:18:   flow: {storage for &columnInt{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:93:18:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:93:18
.\column.go:93:18:     from columnInt{...} (struct literal element) at .\column.go:93:18
.\column.go:95:20: make([]int16, 0, 64) escapes to heap:
.\column.go:95:20:   flow: {storage for &columnInt16{...}} = &{storage for make([]int16, 0, 64)}:
.\column.go:95:20:     from make([]int16, 0, 64) (spill) at .\column.go:95:20
.\column.go:95:20:     from columnInt16{...} (struct literal element) at .\column.go:95:20
.\column.go:95:20: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:95:20:   flow: {storage for &columnInt16{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:95:20:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:95:20
.\column.go:95:20:     from columnInt16{...} (struct literal element) at .\column.go:95:20
.\column.go:97:20: make([]int32, 0, 64) escapes to heap:
.\column.go:97:20:   flow: {storage for &columnInt32{...}} = &{storage for make([]int32, 0, 64)}:
.\column.go:97:20:     from make([]int32, 0, 64) (spill) at .\column.go:97:20
.\column.go:97:20:     from columnInt32{...} (struct literal element) at .\column.go:97:20
.\column.go:97:20: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:97:20:   flow: {storage for &columnInt32{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:97:20:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:97:20
.\column.go:97:20:     from columnInt32{...} (struct literal element) at .\column.go:97:20
.\column.go:99:20: make([]int64, 0, 64) escapes to heap:
.\column.go:99:20:   flow: {storage for &columnInt64{...}} = &{storage for make([]int64, 0, 64)}:
.\column.go:99:20:     from make([]int64, 0, 64) (spill) at .\column.go:99:20
.\column.go:99:20:     from columnInt64{...} (struct literal element) at .\column.go:99:20
.\column.go:99:20: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:99:20:   flow: {storage for &columnInt64{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:99:20:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:99:20
.\column.go:99:20:     from columnInt64{...} (struct literal element) at .\column.go:99:20
.\column.go:101:19: make([]uint, 0, 64) escapes to heap:
.\column.go:101:19:   flow: {storage for &columnUint{...}} = &{storage for make([]uint, 0, 64)}:
.\column.go:101:19:     from make([]uint, 0, 64) (spill) at .\column.go:101:19
.\column.go:101:19:     from columnUint{...} (struct literal element) at .\column.go:101:19
.\column.go:101:19: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:101:19:   flow: {storage for &columnUint{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:101:19:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:101:19
.\column.go:101:19:     from columnUint{...} (struct literal element) at .\column.go:101:19
.\column.go:103:21: make([]uint16, 0, 64) escapes to heap:
.\column.go:103:21:   flow: {storage for &columnUint16{...}} = &{storage for make([]uint16, 0, 64)}:
.\column.go:103:21:     from make([]uint16, 0, 64) (spill) at .\column.go:103:21
.\column.go:103:21:     from columnUint16{...} (struct literal element) at .\column.go:103:21
.\column.go:103:21: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:103:21:   flow: {storage for &columnUint16{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:103:21:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:103:21
.\column.go:103:21:     from columnUint16{...} (struct literal element) at .\column.go:103:21
.\column.go:105:21: make([]uint32, 0, 64) escapes to heap:
.\column.go:105:21:   flow: {storage for &columnUint32{...}} = &{storage for make([]uint32, 0, 64)}:
.\column.go:105:21:     from make([]uint32, 0, 64) (spill) at .\column.go:105:21
.\column.go:105:21:     from columnUint32{...} (struct literal element) at .\column.go:105:21
.\column.go:105:21: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:105:21:   flow: {storage for &columnUint32{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:105:21:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:105:21
.\column.go:105:21:     from columnUint32{...} (struct literal element) at .\column.go:105:21
.\column.go:107:21: make([]uint64, 0, 64) escapes to heap:
.\column.go:107:21:   flow: {storage for &columnUint64{...}} = &{storage for make([]uint64, 0, 64)}:
.\column.go:107:21:     from make([]uint64, 0, 64) (spill) at .\column.go:107:21
.\column.go:107:21:     from columnUint64{...} (struct literal element) at .\column.go:107:21
.\column.go:107:21: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:107:21:   flow: {storage for &columnUint64{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:107:21:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:107:21
.\column.go:107:21:     from columnUint64{...} (struct literal element) at .\column.go:107:21
.\column.go:109:19: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:109:19:   flow: {storage for &columnBool{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:109:19:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:109:19
.\column.go:109:19:     from columnBool{...} (struct literal element) at .\column.go:109:19
.\column.go:109:19: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:109:19:   flow: {storage for &columnBool{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:109:19:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:109:19
.\column.go:109:19:     from columnBool{...} (struct literal element) at .\column.go:109:19
.\column.go:111:17: make([]interface {}, 0, 64) escapes to heap:
.\column.go:111:17:   flow: {storage for &columnAny{...}} = &{storage for make([]interface {}, 0, 64)}:
.\column.go:111:17:     from make([]interface {}, 0, 64) (spill) at .\column.go:111:17
.\column.go:111:17:     from columnAny{...} (struct literal element) at .\column.go:111:17
.\column.go:111:17: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:111:17:   flow: {storage for &columnAny{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:111:17:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:111:17
.\column.go:111:17:     from columnAny{...} (struct literal element) at .\column.go:111:17
.\column.go:89:22: &columnFloat32{...} escapes to heap
.\column.go:89:22: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:89:22: make([]float32, 0, 64) escapes to heap
.\column.go:91:22: &columnFloat64{...} escapes to heap
.\column.go:91:22: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:91:22: make([]float64, 0, 64) escapes to heap
.\column.go:93:18: &columnInt{...} escapes to heap
.\column.go:93:18: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:93:18: make([]int, 0, 64) escapes to heap
.\column.go:95:20: &columnInt16{...} escapes to heap
.\column.go:95:20: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:95:20: make([]int16, 0, 64) escapes to heap
.\column.go:97:20: &columnInt32{...} escapes to heap
.\column.go:97:20: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:97:20: make([]int32, 0, 64) escapes to heap
.\column.go:99:20: &columnInt64{...} escapes to heap
.\column.go:99:20: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:99:20: make([]int64, 0, 64) escapes to heap
.\column.go:101:19: &columnUint{...} escapes to heap
.\column.go:101:19: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:101:19: make([]uint, 0, 64) escapes to heap
.\column.go:103:21: &columnUint16{...} escapes to heap
.\column.go:103:21: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:103:21: make([]uint16, 0, 64) escapes to heap
.\column.go:105:21: &columnUint32{...} escapes to heap
.\column.go:105:21: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:105:21: make([]uint32, 0, 64) escapes to heap
.\column.go:107:21: &columnUint64{...} escapes to heap
.\column.go:107:21: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:107:21: make([]uint64, 0, 64) escapes to heap
.\column.go:109:19: &columnBool{...} escapes to heap
.\column.go:109:19: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:109:19: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:111:17: &columnAny{...} escapes to heap
.\column.go:111:17: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:111:17: make([]interface {}, 0, 64) escapes to heap
.\collection.go:161:38: parameter object leaks to {heap} with derefs=1:
.\collection.go:161:38:   flow: {temp} = object:
.\collection.go:161:38:   flow: v = *{temp}:
.\collection.go:161:38:     from for loop (range-deref) at .\collection.go:162:14
.\collection.go:161:38:   flow: reflect.i = v:
.\collection.go:161:38:     from reflect.i := v (assign-pair) at .\collection.go:163:43
.\collection.go:161:38:   flow: reflect.eface·3 = reflect.i:
.\collection.go:161:38:     from &reflect.i (address-of) at .\collection.go:163:43
.\collection.go:161:38:     from *(*reflect.emptyInterface)(unsafe.Pointer(&reflect.i)) (indirection) at .\collection.go:163:43
.\collection.go:161:38:     from reflect.eface·3 = *(*reflect.emptyInterface)(unsafe.Pointer(&reflect.i)) (assign) at .\collection.go:163:43
.\collection.go:161:38:   flow: reflect.t = reflect.eface·3:
.\collection.go:161:38:     from reflect.eface·3.typ (dot) at .\collection.go:163:43
.\collection.go:161:38:     from reflect.t := reflect.eface·3.typ (assign-pair) at .\collection.go:163:43
.\collection.go:161:38:   flow: ~R0 = reflect.t:
.\collection.go:161:38:     from reflect.Type(reflect.t) (interface-converted) at .\collection.go:163:43
.\collection.go:161:38:     from ~R0 = <N> (assign-pair) at .\collection.go:163:43
.\collection.go:161:38:   flow: ~R0 = ~R0:
.\collection.go:161:38:     from ~R0 = <N> (assign-pair) at .\collection.go:163:43
.\collection.go:161:38:   flow: {heap} = ~R0:
.\collection.go:161:38:     from reflect.Type(~R0).Kind() (call parameter) at .\collection.go:163:51
.\collection.go:161:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:161:7:   flow: {heap} = *c:
.\collection.go:161:7:     from c.CreateColumn(k, ForKind(reflect.Type(~R0).Kind())) (call parameter) at .\collection.go:163:17
.\collection.go:161:7: leaking param content: c
.\collection.go:161:38: leaking param content: object
.\collection.go:423:18: make([]columnEntry, 0, cap(columns)) escapes to heap:
.\collection.go:423:18:   flow: {heap} = &{storage for make([]columnEntry, 0, cap(columns))}:
.\collection.go:423:18:     from make([]columnEntry, 0, cap(columns)) (non-constant size) at .\collection.go:423:18
.\collection.go:429:14: filtered escapes to heap:
.\collection.go:429:14:   flow: {heap} = &{storage for filtered}:
.\collection.go:429:14:     from filtered (spill) at .\collection.go:429:14
.\collection.go:429:14:     from c.cols.Store(filtered) (call parameter) at .\collection.go:429:14
.\collection.go:421:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:421:7:   flow: {heap} = *c:
.\collection.go:421:7:     from c.cols (dot of pointer) at .\collection.go:429:3
.\collection.go:421:7:     from c.cols.Store(filtered) (call parameter) at .\collection.go:429:14
.\collection.go:421:7: leaking param content: c
.\collection.go:421:32: columnName does not escape
.\collection.go:423:18: make([]columnEntry, 0, cap(columns)) escapes to heap
.\collection.go:429:14: filtered escapes to heap
.\collection.go:175:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:175:7:   flow: {heap} = *c:
.\collection.go:175:7:     from c.cols (dot of pointer) at .\collection.go:176:3
.\collection.go:175:7:     from c.cols (address-of) at .\collection.go:176:8
.\collection.go:175:7:     from c.cols.DeleteColumn(columnName) (call parameter) at .\collection.go:176:21
.\collection.go:175:7: leaking param content: c
.\collection.go:175:33: columnName does not escape
.\collection.go:182:45: parameter columnName leaks to {heap} with derefs=0:
.\collection.go:182:45:   flow: {heap} = columnName:
.\collection.go:182:45:     from c.cols.Store(columnName, nil, ... argument...) (call parameter) at .\collection.go:193:14
.\collection.go:190:19: &column{...} escapes to heap:
.\collection.go:190:19:   flow: ~R0 = &{storage for &column{...}}:
.\collection.go:190:19:     from &column{...} (spill) at .\collection.go:190:19
.\collection.go:190:19:     from ~R0 = <N> (assign-pair) at .\collection.go:190:19
.\collection.go:190:19:   flow: ~R0 = ~R0:
.\collection.go:190:19:     from ~R0 = <N> (assign-pair) at .\collection.go:190:19
.\collection.go:190:19:   flow: index = ~R0:
.\collection.go:190:19:     from index := (*column)(~R0) (assign) at .\collection.go:190:8
.\collection.go:190:19:   flow: {heap} = index:
.\collection.go:190:19:     from c.cols.Store(indexName, index, []*column(nil)...) (call parameter) at .\collection.go:192:14
.\collection.go:182:34: parameter indexName leaks to {heap} with derefs=0:
.\collection.go:182:34:   flow: {heap} = indexName:
.\collection.go:182:34:     from c.cols.Store(indexName, index, []*column(nil)...) (call parameter) at .\collection.go:192:14
.\collection.go:182:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:182:7:   flow: {heap} = c:
.\collection.go:182:7:     from c.lock (dot of pointer) at .\collection.go:183:3
.\collection.go:182:7:     from c.lock (address-of) at .\collection.go:183:8
.\collection.go:182:7:     from c.lock.Lock() (call parameter) at .\collection.go:183:13
.\collection.go:190:19: &index{...} escapes to heap:
.\collection.go:190:19:   flow: v = &{storage for &index{...}}:
.\collection.go:190:19:     from &index{...} (spill) at .\collection.go:190:19
.\collection.go:190:19:     from &index{...} (interface-converted) at .\collection.go:190:19
.\collection.go:190:19:     from name, v := indexName, &index{...} (assign-pair) at .\collection.go:190:19
.\collection.go:190:19:   flow: {storage for &column{...}} = v:
.\collection.go:190:19:     from column{...} (struct literal element) at .\collection.go:190:19
.\collection.go:182:34: parameter indexName leaks to {storage for &column{...}} with derefs=0:
.\collection.go:182:34:   flow: indexName = indexName:
.\collection.go:182:34:     from indexName, columnName, rule := indexName, columnName, fn (assign-pair) at .\collection.go:190:19
.\collection.go:182:34:   flow: name = indexName:
.\collection.go:182:34:     from name, v := indexName, &index{...} (assign-pair) at .\collection.go:190:19
.\collection.go:182:34:   flow: {storage for &column{...}} = name:
.\collection.go:182:34:     from column{...} (struct literal element) at .\collection.go:190:19
.\collection.go:182:64: parameter fn leaks to {storage for &index{...}} with derefs=0:
.\collection.go:182:64:   flow: rule = fn:
.\collection.go:182:64:     from indexName, columnName, rule := indexName, columnName, fn (assign-pair) at .\collection.go:190:19
.\collection.go:182:64:   flow: {storage for &index{...}} = rule:
.\collection.go:182:64:     from index{...} (struct literal element) at .\collection.go:190:19
.\collection.go:182:45: parameter columnName leaks to {storage for &index{...}} with derefs=0:
.\collection.go:182:45:   flow: columnName = columnName:
.\collection.go:182:45:     from indexName, columnName, rule := indexName, columnName, fn (assign-pair) at .\collection.go:190:19
.\collection.go:182:45:   flow: {storage for &index{...}} = columnName:
.\collection.go:182:45:     from index{...} (struct literal element) at .\collection.go:190:19
.\collection.go:190:19: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\collection.go:190:19:   flow: {storage for &index{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\collection.go:190:19:     from make(bitmap.Bitmap, 0, 4) (spill) at .\collection.go:190:19
.\collection.go:190:19:     from index{...} (struct literal element) at .\collection.go:190:19
.\collection.go:182:7: leaking param: c
.\collection.go:182:34: leaking param: indexName
.\collection.go:182:45: leaking param: columnName
.\collection.go:182:64: leaking param: fn
.\collection.go:190:19: &index{...} escapes to heap
.\collection.go:190:19: make(bitmap.Bitmap, 0, 4) escapes to heap
.\collection.go:190:19: &column{...} escapes to heap
.\collection.go:193:14: ... argument does not escape
.\collection.go:200:15: func literal does not escape
.\collection.go:446:19: make([]*column, 0, cap(columns[i].cols)) escapes to heap:
.\collection.go:446:19:   flow: {heap} = &{storage for make([]*column, 0, cap(columns[i].cols))}:
.\collection.go:446:19:     from make([]*column, 0, cap(columns[i].cols)) (non-constant size) at .\collection.go:446:19
.\collection.go:456:14: columns escapes to heap:
.\collection.go:456:14:   flow: {heap} = &{storage for columns}:
.\collection.go:456:14:     from columns (spill) at .\collection.go:456:14
.\collection.go:456:14:     from c.cols.Store(columns) (call parameter) at .\collection.go:456:14
.\collection.go:433:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:433:7:   flow: {heap} = *c:
.\collection.go:433:7:     from c.Load(indexName) (call parameter) at .\collection.go:434:21
.\collection.go:433:7: leaking param content: c
.\collection.go:433:31: columnName does not escape
.\collection.go:433:43: indexName does not escape
.\collection.go:446:19: make([]*column, 0, cap(columns[i].cols)) escapes to heap
.\collection.go:456:14: columns escapes to heap
.\collection.go:212:7: parameter c leaks to {heap} with derefs=1:
.\collection.go:212:7:   flow: {heap} = *c:
.\collection.go:212:7:     from c.cols (dot of pointer) at .\collection.go:215:16
.\collection.go:212:7:     from c.cols (address-of) at .\collection.go:215:21
.\collection.go:212:7:     from c.cols.Load(indexName) (call parameter) at .\collection.go:215:26
.\collection.go:212:7: leaking param content: c
.\collection.go:212:32: indexName does not escape
.\collection.go:227:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:227:7:   flow: sync.rw = c:
.\collection.go:227:7:     from c.lock (dot of pointer) at .\collection.go:230:3
.\collection.go:227:7:     from c.lock (address-of) at .\collection.go:230:8
.\collection.go:227:7:     from sync.rw := c.lock (assign-pair) at .\collection.go:230:16
.\collection.go:227:7:   flow: {heap} = sync.rw:
.\collection.go:227:7:     from sync.rw.readerCount (dot of pointer) at .\collection.go:230:16
.\collection.go:227:7:     from &sync.rw.readerCount (address-of) at .\collection.go:230:16
.\collection.go:227:7:     from atomic.AddInt32(&sync.rw.readerCount, int32(-1)) (call parameter) at .\collection.go:230:16
.\collection.go:227:7: parameter c leaks to ~r1 with derefs=0:
.\collection.go:227:7:   flow: ~r1 = c:
.\collection.go:227:7:     from Selector{...} (struct literal element) at .\collection.go:237:17
.\collection.go:227:7:     from return Selector{...}, true (return) at .\collection.go:237:2
.\collection.go:227:7: leaking param: c
.\collection.go:267:7: c does not escape
.\collection.go:321:20: make([]commit.Update, 0, len(change.Updates)) escapes to heap:
.\collection.go:321:20:   flow: {heap} = &{storage for make([]commit.Update, 0, len(change.Updates))}:
.\collection.go:321:20:     from make([]commit.Update, 0, len(change.Updates)) (non-constant size) at .\collection.go:321:20
.\collection.go:294:29: parameter change leaks to {heap} with derefs=1:
.\collection.go:294:29:   flow: {temp} = change:
.\collection.go:294:29:     from change.Updates (dot) at .\collection.go:309:30
.\collection.go:294:29:   flow: log = *{temp}:
.\collection.go:294:29:     from for loop (range-deref) at .\collection.go:309:18
.\collection.go:294:29:   flow: {heap} = log:
.\collection.go:294:29:     from log.Column (dot) at .\collection.go:326:17
.\collection.go:294:29:     from commit.Updates{...} (struct literal element) at .\collection.go:325:53
.\collection.go:294:29:     from append(txn.updates, commit.Updates{...}) (call parameter) at .\collection.go:325:25
.\collection.go:295:22: parameter txn leaks to {heap} with derefs=1:
.\collection.go:295:22:   flow: {heap} = *txn:
.\collection.go:295:22:     from txn.deletes (dot of pointer) at .\collection.go:299:28
.\collection.go:295:22:     from append(txn.deletes, change.Deletes...) (call parameter) at .\collection.go:299:24
.\collection.go:295:22:     from txn.deletes = append(txn.deletes, change.Deletes...) (assign) at .\collection.go:299:16
.\collection.go:294:7: parameter c leaks to {heap} with derefs=0:
.\collection.go:294:7:   flow: {heap} = c:
.\collection.go:294:7:     from c.Query(func literal) (call parameter) at .\collection.go:295:16
.\collection.go:294:7: leaking param: c
.\collection.go:294:29: leaking param content: change
.\collection.go:295:22: leaking param content: txn
.\collection.go:295:17: func literal does not escape
.\collection.go:321:20: make([]commit.Update, 0, len(change.Updates)) escapes to heap
.\collection.go:347:22: make([]columnEntry, 0, capacity) escapes to heap:
.\collection.go:347:22:   flow: {heap} = &{storage for make([]columnEntry, 0, capacity)}:
.\collection.go:347:22:     from make([]columnEntry, 0, capacity) (spill) at .\collection.go:347:22
.\collection.go:347:22:     from data.cols.Store(make([]columnEntry, 0, capacity)) (call parameter) at .\collection.go:347:17
.\collection.go:347:22: make([]columnEntry, 0, capacity) escapes to heap:
.\collection.go:347:22:   flow: {heap} = &{storage for make([]columnEntry, 0, capacity)}:
.\collection.go:347:22:     from make([]columnEntry, 0, capacity) (non-constant size) at .\collection.go:347:22
.\collection.go:347:22: make([]columnEntry, 0, capacity) escapes to heap:
.\collection.go:347:22:   flow: {storage for make([]columnEntry, 0, capacity)} = &{storage for make([]columnEntry, 0, capacity)}:
.\collection.go:347:22:     from make([]columnEntry, 0, capacity) (spill) at .\collection.go:347:22
.\collection.go:347:22:     from make([]columnEntry, 0, capacity) (interface-converted) at .\collection.go:347:22
.\collection.go:344:9: &atomic.Value{} escapes to heap:
.\collection.go:344:9:   flow: data = &{storage for &atomic.Value{}}:
.\collection.go:344:9:     from &atomic.Value{} (spill) at .\collection.go:344:9
.\collection.go:344:9:     from columns{...} (struct literal element) at .\collection.go:343:17
.\collection.go:344:9:     from data := columns{...} (assign) at .\collection.go:343:7
.\collection.go:344:9:   flow: {heap} = data:
.\collection.go:344:9:     from data.cols (dot) at .\collection.go:347:6
.\collection.go:344:9:     from data.cols.Store(make([]columnEntry, 0, capacity)) (call parameter) at .\collection.go:347:17
.\collection.go:344:9: &atomic.Value{} escapes to heap
.\collection.go:347:22: make([]columnEntry, 0, capacity) escapes to heap
.\collection.go:347:22: make([]columnEntry, 0, capacity) escapes to heap
.\column.go:25:13: column does not escape
.\column.go:126:9: &column{...} escapes to heap:
.\column.go:126:9:   flow: ~r2 = &{storage for &column{...}}:
.\column.go:126:9:     from &column{...} (spill) at .\column.go:126:9
.\column.go:126:9:     from return &column{...} (return) at .\column.go:126:2
.\column.go:125:29: parameter v leaks to {storage for &column{...}} with derefs=0:
.\column.go:125:29:   flow: {storage for &column{...}} = v:
.\column.go:125:29:     from column{...} (struct literal element) at .\column.go:126:16
.\column.go:125:16: parameter name leaks to {storage for &column{...}} with derefs=0:
.\column.go:125:16:   flow: {storage for &column{...}} = name:
.\column.go:125:16:     from column{...} (struct literal element) at .\column.go:126:16
.\column.go:125:16: leaking param: name
.\column.go:125:29: leaking param: v
.\column.go:126:9: &column{...} escapes to heap
.\column.go:134:7: c does not escape
.\column.go:139:7: c does not escape
.\column.go:150:37: parameter items leaks to {heap} with derefs=0:
.\column.go:150:37:   flow: {heap} = items:
.\column.go:150:37:     from c.Column.Delete(offset, items) (call parameter) at .\column.go:151:17
.\column.go:150:7: parameter c leaks to {heap} with derefs=1:
.\column.go:150:7:   flow: {heap} = *c:
.\column.go:150:7:     from c.Column (dot of pointer) at .\column.go:151:3
.\column.go:150:7:     from c.Column.Delete(offset, items) (call parameter) at .\column.go:151:17
.\column.go:150:7: leaking param content: c
.\column.go:150:37: leaking param: items
.\column.go:155:7: parameter c leaks to {heap} with derefs=1:
.\column.go:155:7:   flow: {heap} = *c:
.\column.go:155:7:     from c.Column (dot of pointer) at .\column.go:156:11
.\column.go:155:7:     from c.Column.Value(idx) (call parameter) at .\column.go:156:24
.\column.go:155:7: leaking param content: c
.\column.go:161:7: parameter c leaks to {heap} with derefs=1:
.\column.go:161:7:   flow: column = *c:
.\column.go:161:7:     from c.Column (dot of pointer) at .\column.go:162:22
.\column.go:161:7:     from c.Column.(Textual) (dot) at .\column.go:162:29
.\column.go:161:7:     from column, text = c.Column.(Textual) (assign-pair-dot-type) at .\column.go:162:18
.\column.go:161:7:   flow: {heap} = column:
.\column.go:161:7:     from column.LoadString(idx) (call parameter) at .\column.go:163:28
.\column.go:161:7: leaking param content: c
.\column.go:169:7: parameter c leaks to {heap} with derefs=1:
.\column.go:169:7:   flow: n = *c:
.\column.go:169:7:     from c.Column (dot of pointer) at .\column.go:170:21
.\column.go:169:7:     from c.Column.(Numeric) (dot) at .\column.go:170:28
.\column.go:169:7:     from n, contains = c.Column.(Numeric) (assign-pair-dot-type) at .\column.go:170:17
.\column.go:169:7:   flow: {heap} = n:
.\column.go:169:7:     from n.LoadFloat64(idx) (call parameter) at .\column.go:171:24
.\column.go:169:7: leaking param content: c
.\column.go:177:7: parameter c leaks to {heap} with derefs=1:
.\column.go:177:7:   flow: n = *c:
.\column.go:177:7:     from c.Column (dot of pointer) at .\column.go:178:21
.\column.go:177:7:     from c.Column.(Numeric) (dot) at .\column.go:178:28
.\column.go:177:7:     from n, contains = c.Column.(Numeric) (assign-pair-dot-type) at .\column.go:178:17
.\column.go:177:7:   flow: {heap} = n:
.\column.go:177:7:     from n.LoadInt64(idx) (call parameter) at .\column.go:179:22
.\column.go:177:7: leaking param content: c
.\column.go:185:7: parameter c leaks to {heap} with derefs=1:
.\column.go:185:7:   flow: n = *c:
.\column.go:185:7:     from c.Column (dot of pointer) at .\column.go:186:21
.\column.go:185:7:     from c.Column.(Numeric) (dot) at .\column.go:186:28
.\column.go:185:7:     from n, contains = c.Column.(Numeric) (assign-pair-dot-type) at .\column.go:186:17
.\column.go:185:7:   flow: {heap} = n:
.\column.go:185:7:     from n.LoadUint64(idx) (call parameter) at .\column.go:187:23
.\column.go:185:7: leaking param content: c
.\column.go:202:9: &columnAny{...} escapes to heap:
.\column.go:202:9:   flow: ~r0 = &{storage for &columnAny{...}}:
.\column.go:202:9:     from &columnAny{...} (spill) at .\column.go:202:9
.\column.go:202:9:     from &columnAny{...} (interface-converted) at .\column.go:202:9
.\column.go:202:9:     from return &columnAny{...} (return) at .\column.go:202:2
.\column.go:204:13: make([]interface {}, 0, 64) escapes to heap:
.\column.go:204:13:   flow: {storage for &columnAny{...}} = &{storage for make([]interface {}, 0, 64)}:
.\column.go:204:13:     from make([]interface {}, 0, 64) (spill) at .\column.go:204:13
.\column.go:204:13:     from columnAny{...} (struct literal element) at .\column.go:202:19
.\column.go:203:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:203:13:   flow: {storage for &columnAny{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:203:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:203:13
.\column.go:203:13:     from columnAny{...} (struct literal element) at .\column.go:202:19
.\column.go:202:9: &columnAny{...} escapes to heap
.\column.go:203:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:204:13: make([]interface {}, 0, 64) escapes to heap
.\column.go:215:10: (*columnAny).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column.go:220:15: make([]interface {}, idx + 1, int(~R0)) escapes to heap:
.\column.go:220:15:   flow: {heap} = &{storage for make([]interface {}, idx + 1, int(~R0))}:
.\column.go:220:15:     from make([]interface {}, idx + 1, int(~R0)) (non-constant size) at .\column.go:220:15
.\column.go:209:7: parameter c leaks to {heap} with derefs=2:
.\column.go:209:7:   flow: {heap} = **c:
.\column.go:209:7:     from c.data (dot of pointer) at .\column.go:221:15
.\column.go:209:7:     from copy(clone, c.data) (call parameter) at .\column.go:221:6
.\column.go:209:7:     from copy(clone, c.data) (copied slice) at .\column.go:221:6
.\column.go:209:7: leaking param content: c
.\column.go:220:15: make([]interface {}, idx + 1, int(~R0)) escapes to heap
.\column.go:226:28: parameter updates leaks to {heap} with derefs=1:
.\column.go:226:28:   flow: {temp} = updates:
.\column.go:226:28:   flow: u = *{temp}:
.\column.go:226:28:     from for loop (range-deref) at .\column.go:229:14
.\column.go:226:28:   flow: {heap} = u:
.\column.go:226:28:     from u.Value (dot) at .\column.go:232:23
.\column.go:226:28:     from c.data[u.Index] = u.Value (assign) at .\column.go:232:20
.\column.go:226:7: c does not escape
.\column.go:226:28: leaking param content: updates
.\column.go:238:7: c does not escape
.\column.go:238:40: items does not escape
.\column.go:244:7: parameter c leaks to v with derefs=2:
.\column.go:244:7:   flow: v = **c:
.\column.go:244:7:     from c.data (dot of pointer) at .\column.go:246:12
.\column.go:244:7:     from c.data[idx] (dot of pointer) at .\column.go:246:17
.\column.go:244:7:     from v, ok = <N> (assign-pair) at .\column.go:246:9
.\column.go:244:7: leaking param: c to result v level=2
.\column.go:252:7: c does not escape
.\column.go:257:7: parameter c leaks to ~r0 with derefs=0:
.\column.go:257:7:   flow: ~r0 = c:
.\column.go:257:7:     from c.fill (dot of pointer) at .\column.go:258:11
.\column.go:257:7:     from &c.fill (address-of) at .\column.go:258:9
.\column.go:257:7:     from return &c.fill (return) at .\column.go:258:2
.\column.go:257:7: leaking param: c to result ~r0 level=0
.\column.go:262:7: parameter c leaks to ~r1 with derefs=3:
.\column.go:262:7:   flow: c = c:
.\column.go:262:7:     from c, idx := c, idx (assign-pair) at .\column.go:263:19
.\column.go:262:7:   flow: v = **c:
.\column.go:262:7:     from c.data (dot of pointer) at .\column.go:263:19
.\column.go:262:7:     from c.data[idx] (dot of pointer) at .\column.go:263:19
.\column.go:262:7:     from v, ok = <N> (assign-pair) at .\column.go:263:19
.\column.go:262:7:   flow: v = v:
.\column.go:262:7:     from v, has := (interface {})(v), ok (assign-pair) at .\column.go:263:9
.\column.go:262:7:   flow: s = *v:
.\column.go:262:7:     from v.(string) (dot) at .\column.go:264:12
.\column.go:262:7:     from s, ok = v.(string) (assign-pair-dot-type) at .\column.go:264:8
.\column.go:262:7:   flow: ~r1 = s:
.\column.go:262:7:     from return s, has && ok (return) at .\column.go:265:2
.\column.go:262:7: leaking param: c to result ~r1 level=3
.\column.go:270:7: parameter c leaks to {heap} with derefs=3:
.\column.go:270:7:   flow: {heap} = ***c:
.\column.go:270:7:     from c.data (dot of pointer) at .\column.go:273:50
.\column.go:270:7:     from c.data[idx] (dot of pointer) at .\column.go:273:55
.\column.go:270:7:     from c.data[idx].(string) (dot) at .\column.go:273:60
.\column.go:270:7:     from predicate(c.data[idx].(string)) (call parameter) at .\column.go:273:48
.\column.go:270:7: leaking param content: c
.\column.go:270:34: index does not escape
.\column.go:270:56: predicate does not escape
.\column.go:272:15: func literal does not escape
.\column.go:287:9: &columnBool{...} escapes to heap:
.\column.go:287:9:   flow: ~r0 = &{storage for &columnBool{...}}:
.\column.go:287:9:     from &columnBool{...} (spill) at .\column.go:287:9
.\column.go:287:9:     from &columnBool{...} (interface-converted) at .\column.go:287:9
.\column.go:287:9:     from return &columnBool{...} (return) at .\column.go:287:2
.\column.go:289:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:289:13:   flow: {storage for &columnBool{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:289:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:289:13
.\column.go:289:13:     from columnBool{...} (struct literal element) at .\column.go:287:20
.\column.go:288:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column.go:288:13:   flow: {storage for &columnBool{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column.go:288:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column.go:288:13
.\column.go:288:13:     from columnBool{...} (struct literal element) at .\column.go:287:20
.\column.go:287:9: &columnBool{...} escapes to heap
.\column.go:288:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:289:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column.go:294:7: c does not escape
.\column.go:299:7: c does not escape
.\column.go:299:29: updates does not escape
.\column.go:312:24: c.data.Contains(idx) escapes to heap:
.\column.go:312:24:   flow: ~r1 = &{storage for c.data.Contains(idx)}:
.\column.go:312:24:     from c.data.Contains(idx) (spill) at .\column.go:312:24
.\column.go:312:24:     from return c.data.Contains(idx), bool(~R0) (return) at .\column.go:312:2
.\column.go:311:7: c does not escape
.\column.go:312:24: c.data.Contains(idx) escapes to heap
.\column.go:316:7: c does not escape
.\column.go:316:41: items does not escape
.\column.go:324:7: c does not escape
.\column.go:329:7: parameter c leaks to ~r0 with derefs=0:
.\column.go:329:7:   flow: ~r0 = c:
.\column.go:329:7:     from c.data (dot of pointer) at .\column.go:330:11
.\column.go:329:7:     from &c.data (address-of) at .\column.go:330:9
.\column.go:329:7:     from return &c.data (return) at .\column.go:330:2
.\column.go:329:7: leaking param: c to result ~r0 level=0
.\column_generate.go:21:9: &columnnumber{...} escapes to heap:
.\column_generate.go:21:9:   flow: ~r0 = &{storage for &columnnumber{...}}:
.\column_generate.go:21:9:     from &columnnumber{...} (spill) at .\column_generate.go:21:9
.\column_generate.go:21:9:     from &columnnumber{...} (interface-converted) at .\column_generate.go:21:9
.\column_generate.go:21:9:     from return &columnnumber{...} (return) at .\column_generate.go:21:2
.\column_generate.go:23:13: make([]number, 0, 64) escapes to heap:
.\column_generate.go:23:13:   flow: {storage for &columnnumber{...}} = &{storage for make([]number, 0, 64)}:
.\column_generate.go:23:13:     from make([]number, 0, 64) (spill) at .\column_generate.go:23:13
.\column_generate.go:23:13:     from columnnumber{...} (struct literal element) at .\column_generate.go:21:22
.\column_generate.go:22:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_generate.go:22:13:   flow: {storage for &columnnumber{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_generate.go:22:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_generate.go:22:13
.\column_generate.go:22:13:     from columnnumber{...} (struct literal element) at .\column_generate.go:21:22
.\column_generate.go:21:9: &columnnumber{...} escapes to heap
.\column_generate.go:22:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_generate.go:23:13: make([]number, 0, 64) escapes to heap
.\column_generate.go:34:10: (*columnnumber).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_generate.go:39:15: make([]number, idx + 1, int(~R0)) escapes to heap:
.\column_generate.go:39:15:   flow: {heap} = &{storage for make([]number, idx + 1, int(~R0))}:
.\column_generate.go:39:15:     from make([]number, idx + 1, int(~R0)) (non-constant size) at .\column_generate.go:39:15
.\column_generate.go:28:7: c does not escape
.\column_generate.go:39:15: make([]number, idx + 1, int(~R0)) escapes to heap
.\column_generate.go:62:5: value escapes to heap:
.\column_generate.go:62:5:   flow: {heap} = &{storage for value}:
.\column_generate.go:62:5:     from value (spill) at .\column_generate.go:62:5
.\column_generate.go:62:5:     from commit.Update{...} (struct literal element) at .\column_generate.go:59:30
.\column_generate.go:62:5:     from updates[i] = commit.Update{...} (assign) at .\column_generate.go:59:15
.\column_generate.go:45:7: c does not escape
.\column_generate.go:45:31: updates does not escape
.\column_generate.go:62:5: value escapes to heap
.\column_generate.go:69:7: c does not escape
.\column_generate.go:69:43: items does not escape
.\column_generate.go:75:7: c does not escape
.\column_generate.go:80:7: parameter c leaks to ~r0 with derefs=0:
.\column_generate.go:80:7:   flow: ~r0 = c:
.\column_generate.go:80:7:     from c.fill (dot of pointer) at .\column_generate.go:81:11
.\column_generate.go:80:7:     from &c.fill (address-of) at .\column_generate.go:81:9
.\column_generate.go:80:7:     from return &c.fill (return) at .\column_generate.go:81:2
.\column_generate.go:80:7: leaking param: c to result ~r0 level=0
.\column_generate.go:88:9: c.data[idx] escapes to heap:
.\column_generate.go:88:9:   flow: v = &{storage for c.data[idx]}:
.\column_generate.go:88:9:     from c.data[idx] (spill) at .\column_generate.go:88:9
.\column_generate.go:88:9:     from v, ok = <N> (assign-pair) at .\column_generate.go:88:9
.\column_generate.go:86:4: number(0) escapes to heap:
.\column_generate.go:86:4:   flow: v = &{storage for number(0)}:
.\column_generate.go:86:4:     from number(0) (spill) at .\column_generate.go:86:4
.\column_generate.go:86:4:     from v = number(0) (assign) at .\column_generate.go:86:4
.\column_generate.go:85:7: c does not escape
.\column_generate.go:86:4: number(0) escapes to heap
.\column_generate.go:88:9: c.data[idx] escapes to heap
.\column_generate.go:94:7: c does not escape
.\column_generate.go:102:7: c does not escape
.\column_generate.go:110:7: c does not escape
.\column_generate.go:118:7: c does not escape
.\column_generate.go:118:38: index does not escape
.\column_generate.go:118:60: predicate does not escape
.\column_generate.go:120:15: func literal does not escape
.\column_generate.go:126:7: c does not escape
.\column_generate.go:126:36: index does not escape
.\column_generate.go:126:58: predicate does not escape
.\column_generate.go:128:15: func literal does not escape
.\column_generate.go:134:7: c does not escape
.\column_generate.go:134:37: index does not escape
.\column_generate.go:134:59: predicate does not escape
.\column_generate.go:136:15: func literal does not escape
.\column_index.go:27:18: &column{...} escapes to heap:
.\column_index.go:27:18:   flow: ~R0 = &{storage for &column{...}}:
.\column_index.go:27:18:     from &column{...} (spill) at .\column_index.go:27:18
.\column_index.go:27:18:     from ~R0 = <N> (assign-pair) at .\column_index.go:27:18
.\column_index.go:27:18:   flow: ~r3 = ~R0:
.\column_index.go:27:18:     from return (*column)(~R0) (return) at .\column_index.go:27:2
.\column_index.go:27:30: &index{...} escapes to heap:
.\column_index.go:27:30:   flow: v = &{storage for &index{...}}:
.\column_index.go:27:30:     from &index{...} (spill) at .\column_index.go:27:30
.\column_index.go:27:30:     from &index{...} (interface-converted) at .\column_index.go:27:30
.\column_index.go:27:30:     from name, v := indexName, &index{...} (assign-pair) at .\column_index.go:27:18
.\column_index.go:27:30:   flow: {storage for &column{...}} = v:
.\column_index.go:27:30:     from column{...} (struct literal element) at .\column_index.go:27:18
.\column_index.go:26:15: parameter indexName leaks to {storage for &column{...}} with derefs=0:
.\column_index.go:26:15:   flow: name = indexName:
.\column_index.go:26:15:     from name, v := indexName, &index{...} (assign-pair) at .\column_index.go:27:18
.\column_index.go:26:15:   flow: {storage for &column{...}} = name:
.\column_index.go:26:15:     from column{...} (struct literal element) at .\column_index.go:27:18
.\column_index.go:26:45: parameter rule leaks to {storage for &index{...}} with derefs=0:
.\column_index.go:26:45:   flow: {storage for &index{...}} = rule:
.\column_index.go:26:45:     from index{...} (struct literal element) at .\column_index.go:27:36
.\column_index.go:26:26: parameter columnName leaks to {storage for &index{...}} with derefs=0:
.\column_index.go:26:26:   flow: {storage for &index{...}} = columnName:
.\column_index.go:26:26:     from index{...} (struct literal element) at .\column_index.go:27:36
.\column_index.go:28:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_index.go:28:13:   flow: {storage for &index{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_index.go:28:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_index.go:28:13
.\column_index.go:28:13:     from index{...} (struct literal element) at .\column_index.go:27:36
.\column_index.go:26:15: leaking param: indexName
.\column_index.go:26:26: leaking param: columnName
.\column_index.go:26:45: leaking param: rule
.\column_index.go:27:30: &index{...} escapes to heap
.\column_index.go:28:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_index.go:27:18: &column{...} escapes to heap
.\column_index.go:35:7: c does not escape
.\column_index.go:40:7: parameter c leaks to ~r0 with derefs=1:
.\column_index.go:40:7:   flow: ~r0 = *c:
.\column_index.go:40:7:     from c.prop (dot of pointer) at .\column_index.go:41:10
.\column_index.go:40:7:     from return c.prop (return) at .\column_index.go:41:2
.\column_index.go:40:7: leaking param: c to result ~r0 level=1
.\column_index.go:45:24: parameter updates leaks to {heap} with derefs=1:
.\column_index.go:45:24:   flow: {temp} = updates:
.\column_index.go:45:24:   flow: u = *{temp}:
.\column_index.go:45:24:     from for loop (range-deref) at .\column_index.go:50:14
.\column_index.go:45:24:   flow: {heap} = u:
.\column_index.go:45:24:     from u.Value (dot) at .\column_index.go:52:15
.\column_index.go:45:24:     from c.rule(u.Value) (call parameter) at .\column_index.go:52:13
.\column_index.go:45:7: c does not escape
.\column_index.go:45:24: leaking param content: updates
.\column_index.go:62:7: c does not escape
.\column_index.go:62:36: items does not escape
.\column_index.go:70:9: c.fill.Contains(idx) escapes to heap:
.\column_index.go:70:9:   flow: v = &{storage for c.fill.Contains(idx)}:
.\column_index.go:70:9:     from c.fill.Contains(idx) (spill) at .\column_index.go:70:9
.\column_index.go:70:9:     from v, ok = <N> (assign-pair) at .\column_index.go:70:9
.\column_index.go:68:7: c does not escape
.\column_index.go:70:9: c.fill.Contains(idx) escapes to heap
.\column_index.go:76:7: c does not escape
.\column_index.go:81:7: parameter c leaks to ~r0 with derefs=0:
.\column_index.go:81:7:   flow: ~r0 = c:
.\column_index.go:81:7:     from c.fill (dot of pointer) at .\column_index.go:82:11
.\column_index.go:81:7:     from &c.fill (address-of) at .\column_index.go:82:9
.\column_index.go:81:7:     from return &c.fill (return) at .\column_index.go:82:2
.\column_index.go:81:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:22:9: &columnFloat32{...} escapes to heap:
.\column_numbers.go:22:9:   flow: ~r0 = &{storage for &columnFloat32{...}}:
.\column_numbers.go:22:9:     from &columnFloat32{...} (spill) at .\column_numbers.go:22:9
.\column_numbers.go:22:9:     from &columnFloat32{...} (interface-converted) at .\column_numbers.go:22:9
.\column_numbers.go:22:9:     from return &columnFloat32{...} (return) at .\column_numbers.go:22:2
.\column_numbers.go:24:13: make([]float32, 0, 64) escapes to heap:
.\column_numbers.go:24:13:   flow: {storage for &columnFloat32{...}} = &{storage for make([]float32, 0, 64)}:
.\column_numbers.go:24:13:     from make([]float32, 0, 64) (spill) at .\column_numbers.go:24:13
.\column_numbers.go:24:13:     from columnFloat32{...} (struct literal element) at .\column_numbers.go:22:23
.\column_numbers.go:23:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:23:13:   flow: {storage for &columnFloat32{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:23:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:23:13
.\column_numbers.go:23:13:     from columnFloat32{...} (struct literal element) at .\column_numbers.go:22:23
.\column_numbers.go:22:9: &columnFloat32{...} escapes to heap
.\column_numbers.go:23:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:24:13: make([]float32, 0, 64) escapes to heap
.\column_numbers.go:35:10: (*columnFloat32).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:40:15: make([]float32, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:40:15:   flow: {heap} = &{storage for make([]float32, idx + 1, int(~R0))}:
.\column_numbers.go:40:15:     from make([]float32, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:40:15
.\column_numbers.go:29:7: c does not escape
.\column_numbers.go:40:15: make([]float32, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:63:5: value escapes to heap:
.\column_numbers.go:63:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:63:5:     from value (spill) at .\column_numbers.go:63:5
.\column_numbers.go:63:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:60:30
.\column_numbers.go:63:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:60:15
.\column_numbers.go:46:7: c does not escape
.\column_numbers.go:46:32: updates does not escape
.\column_numbers.go:63:5: value escapes to heap
.\column_numbers.go:70:7: c does not escape
.\column_numbers.go:70:44: items does not escape
.\column_numbers.go:76:7: c does not escape
.\column_numbers.go:81:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:81:7:   flow: ~r0 = c:
.\column_numbers.go:81:7:     from c.fill (dot of pointer) at .\column_numbers.go:82:11
.\column_numbers.go:81:7:     from &c.fill (address-of) at .\column_numbers.go:82:9
.\column_numbers.go:81:7:     from return &c.fill (return) at .\column_numbers.go:82:2
.\column_numbers.go:81:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:89:9: c.data[idx] escapes to heap:
.\column_numbers.go:89:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:89:9:     from c.data[idx] (spill) at .\column_numbers.go:89:9
.\column_numbers.go:89:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:89:9
.\column_numbers.go:87:4: float32(0) escapes to heap:
.\column_numbers.go:87:4:   flow: v = &{storage for float32(0)}:
.\column_numbers.go:87:4:     from float32(0) (spill) at .\column_numbers.go:87:4
.\column_numbers.go:87:4:     from v = float32(0) (assign) at .\column_numbers.go:87:4
.\column_numbers.go:86:7: c does not escape
.\column_numbers.go:87:4: float32(0) escapes to heap
.\column_numbers.go:89:9: c.data[idx] escapes to heap
.\column_numbers.go:95:7: c does not escape
.\column_numbers.go:103:7: c does not escape
.\column_numbers.go:111:7: c does not escape
.\column_numbers.go:119:7: c does not escape
.\column_numbers.go:119:39: index does not escape
.\column_numbers.go:119:61: predicate does not escape
.\column_numbers.go:121:15: func literal does not escape
.\column_numbers.go:127:7: c does not escape
.\column_numbers.go:127:37: index does not escape
.\column_numbers.go:127:59: predicate does not escape
.\column_numbers.go:129:15: func literal does not escape
.\column_numbers.go:135:7: c does not escape
.\column_numbers.go:135:38: index does not escape
.\column_numbers.go:135:60: predicate does not escape
.\column_numbers.go:137:15: func literal does not escape
.\column_numbers.go:152:9: &columnFloat64{...} escapes to heap:
.\column_numbers.go:152:9:   flow: ~r0 = &{storage for &columnFloat64{...}}:
.\column_numbers.go:152:9:     from &columnFloat64{...} (spill) at .\column_numbers.go:152:9
.\column_numbers.go:152:9:     from &columnFloat64{...} (interface-converted) at .\column_numbers.go:152:9
.\column_numbers.go:152:9:     from return &columnFloat64{...} (return) at .\column_numbers.go:152:2
.\column_numbers.go:154:13: make([]float64, 0, 64) escapes to heap:
.\column_numbers.go:154:13:   flow: {storage for &columnFloat64{...}} = &{storage for make([]float64, 0, 64)}:
.\column_numbers.go:154:13:     from make([]float64, 0, 64) (spill) at .\column_numbers.go:154:13
.\column_numbers.go:154:13:     from columnFloat64{...} (struct literal element) at .\column_numbers.go:152:23
.\column_numbers.go:153:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:153:13:   flow: {storage for &columnFloat64{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:153:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:153:13
.\column_numbers.go:153:13:     from columnFloat64{...} (struct literal element) at .\column_numbers.go:152:23
.\column_numbers.go:152:9: &columnFloat64{...} escapes to heap
.\column_numbers.go:153:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:154:13: make([]float64, 0, 64) escapes to heap
.\column_numbers.go:165:10: (*columnFloat64).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:170:15: make([]float64, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:170:15:   flow: {heap} = &{storage for make([]float64, idx + 1, int(~R0))}:
.\column_numbers.go:170:15:     from make([]float64, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:170:15
.\column_numbers.go:159:7: c does not escape
.\column_numbers.go:170:15: make([]float64, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:193:5: value escapes to heap:
.\column_numbers.go:193:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:193:5:     from value (spill) at .\column_numbers.go:193:5
.\column_numbers.go:193:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:190:30
.\column_numbers.go:193:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:190:15
.\column_numbers.go:176:7: c does not escape
.\column_numbers.go:176:32: updates does not escape
.\column_numbers.go:193:5: value escapes to heap
.\column_numbers.go:200:7: c does not escape
.\column_numbers.go:200:44: items does not escape
.\column_numbers.go:206:7: c does not escape
.\column_numbers.go:211:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:211:7:   flow: ~r0 = c:
.\column_numbers.go:211:7:     from c.fill (dot of pointer) at .\column_numbers.go:212:11
.\column_numbers.go:211:7:     from &c.fill (address-of) at .\column_numbers.go:212:9
.\column_numbers.go:211:7:     from return &c.fill (return) at .\column_numbers.go:212:2
.\column_numbers.go:211:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:219:9: c.data[idx] escapes to heap:
.\column_numbers.go:219:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:219:9:     from c.data[idx] (spill) at .\column_numbers.go:219:9
.\column_numbers.go:219:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:219:9
.\column_numbers.go:217:4: float64(0) escapes to heap:
.\column_numbers.go:217:4:   flow: v = &{storage for float64(0)}:
.\column_numbers.go:217:4:     from float64(0) (spill) at .\column_numbers.go:217:4
.\column_numbers.go:217:4:     from v = float64(0) (assign) at .\column_numbers.go:217:4
.\column_numbers.go:216:7: c does not escape
.\column_numbers.go:217:4: float64(0) escapes to heap
.\column_numbers.go:219:9: c.data[idx] escapes to heap
.\column_numbers.go:225:7: c does not escape
.\column_numbers.go:233:7: c does not escape
.\column_numbers.go:241:7: c does not escape
.\column_numbers.go:249:7: c does not escape
.\column_numbers.go:249:39: index does not escape
.\column_numbers.go:249:61: predicate does not escape
.\column_numbers.go:251:15: func literal does not escape
.\column_numbers.go:257:7: c does not escape
.\column_numbers.go:257:37: index does not escape
.\column_numbers.go:257:59: predicate does not escape
.\column_numbers.go:259:15: func literal does not escape
.\column_numbers.go:265:7: c does not escape
.\column_numbers.go:265:38: index does not escape
.\column_numbers.go:265:60: predicate does not escape
.\column_numbers.go:267:15: func literal does not escape
.\column_numbers.go:282:9: &columnInt{...} escapes to heap:
.\column_numbers.go:282:9:   flow: ~r0 = &{storage for &columnInt{...}}:
.\column_numbers.go:282:9:     from &columnInt{...} (spill) at .\column_numbers.go:282:9
.\column_numbers.go:282:9:     from &columnInt{...} (interface-converted) at .\column_numbers.go:282:9
.\column_numbers.go:282:9:     from return &columnInt{...} (return) at .\column_numbers.go:282:2
.\column_numbers.go:284:13: make([]int, 0, 64) escapes to heap:
.\column_numbers.go:284:13:   flow: {storage for &columnInt{...}} = &{storage for make([]int, 0, 64)}:
.\column_numbers.go:284:13:     from make([]int, 0, 64) (spill) at .\column_numbers.go:284:13
.\column_numbers.go:284:13:     from columnInt{...} (struct literal element) at .\column_numbers.go:282:19
.\column_numbers.go:283:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:283:13:   flow: {storage for &columnInt{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:283:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:283:13
.\column_numbers.go:283:13:     from columnInt{...} (struct literal element) at .\column_numbers.go:282:19
.\column_numbers.go:282:9: &columnInt{...} escapes to heap
.\column_numbers.go:283:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:284:13: make([]int, 0, 64) escapes to heap
.\column_numbers.go:295:10: (*columnInt).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:300:15: make([]int, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:300:15:   flow: {heap} = &{storage for make([]int, idx + 1, int(~R0))}:
.\column_numbers.go:300:15:     from make([]int, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:300:15
.\column_numbers.go:289:7: c does not escape
.\column_numbers.go:300:15: make([]int, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:323:5: value escapes to heap:
.\column_numbers.go:323:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:323:5:     from value (spill) at .\column_numbers.go:323:5
.\column_numbers.go:323:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:320:30
.\column_numbers.go:323:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:320:15
.\column_numbers.go:306:7: c does not escape
.\column_numbers.go:306:28: updates does not escape
.\column_numbers.go:323:5: value escapes to heap
.\column_numbers.go:330:7: c does not escape
.\column_numbers.go:330:40: items does not escape
.\column_numbers.go:336:7: c does not escape
.\column_numbers.go:341:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:341:7:   flow: ~r0 = c:
.\column_numbers.go:341:7:     from c.fill (dot of pointer) at .\column_numbers.go:342:11
.\column_numbers.go:341:7:     from &c.fill (address-of) at .\column_numbers.go:342:9
.\column_numbers.go:341:7:     from return &c.fill (return) at .\column_numbers.go:342:2
.\column_numbers.go:341:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:349:9: c.data[idx] escapes to heap:
.\column_numbers.go:349:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:349:9:     from c.data[idx] (spill) at .\column_numbers.go:349:9
.\column_numbers.go:349:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:349:9
.\column_numbers.go:347:4: int(0) escapes to heap:
.\column_numbers.go:347:4:   flow: v = &{storage for int(0)}:
.\column_numbers.go:347:4:     from int(0) (spill) at .\column_numbers.go:347:4
.\column_numbers.go:347:4:     from v = int(0) (assign) at .\column_numbers.go:347:4
.\column_numbers.go:346:7: c does not escape
.\column_numbers.go:347:4: int(0) escapes to heap
.\column_numbers.go:349:9: c.data[idx] escapes to heap
.\column_numbers.go:355:7: c does not escape
.\column_numbers.go:363:7: c does not escape
.\column_numbers.go:371:7: c does not escape
.\column_numbers.go:379:7: c does not escape
.\column_numbers.go:379:35: index does not escape
.\column_numbers.go:379:57: predicate does not escape
.\column_numbers.go:381:15: func literal does not escape
.\column_numbers.go:387:7: c does not escape
.\column_numbers.go:387:33: index does not escape
.\column_numbers.go:387:55: predicate does not escape
.\column_numbers.go:389:15: func literal does not escape
.\column_numbers.go:395:7: c does not escape
.\column_numbers.go:395:34: index does not escape
.\column_numbers.go:395:56: predicate does not escape
.\column_numbers.go:397:15: func literal does not escape
.\column_numbers.go:412:9: &columnInt16{...} escapes to heap:
.\column_numbers.go:412:9:   flow: ~r0 = &{storage for &columnInt16{...}}:
.\column_numbers.go:412:9:     from &columnInt16{...} (spill) at .\column_numbers.go:412:9
.\column_numbers.go:412:9:     from &columnInt16{...} (interface-converted) at .\column_numbers.go:412:9
.\column_numbers.go:412:9:     from return &columnInt16{...} (return) at .\column_numbers.go:412:2
.\column_numbers.go:414:13: make([]int16, 0, 64) escapes to heap:
.\column_numbers.go:414:13:   flow: {storage for &columnInt16{...}} = &{storage for make([]int16, 0, 64)}:
.\column_numbers.go:414:13:     from make([]int16, 0, 64) (spill) at .\column_numbers.go:414:13
.\column_numbers.go:414:13:     from columnInt16{...} (struct literal element) at .\column_numbers.go:412:21
.\column_numbers.go:413:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:413:13:   flow: {storage for &columnInt16{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:413:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:413:13
.\column_numbers.go:413:13:     from columnInt16{...} (struct literal element) at .\column_numbers.go:412:21
.\column_numbers.go:412:9: &columnInt16{...} escapes to heap
.\column_numbers.go:413:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:414:13: make([]int16, 0, 64) escapes to heap
.\column_numbers.go:425:10: (*columnInt16).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:430:15: make([]int16, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:430:15:   flow: {heap} = &{storage for make([]int16, idx + 1, int(~R0))}:
.\column_numbers.go:430:15:     from make([]int16, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:430:15
.\column_numbers.go:419:7: c does not escape
.\column_numbers.go:430:15: make([]int16, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:453:5: value escapes to heap:
.\column_numbers.go:453:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:453:5:     from value (spill) at .\column_numbers.go:453:5
.\column_numbers.go:453:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:450:30
.\column_numbers.go:453:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:450:15
.\column_numbers.go:436:7: c does not escape
.\column_numbers.go:436:30: updates does not escape
.\column_numbers.go:453:5: value escapes to heap
.\column_numbers.go:460:7: c does not escape
.\column_numbers.go:460:42: items does not escape
.\column_numbers.go:466:7: c does not escape
.\column_numbers.go:471:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:471:7:   flow: ~r0 = c:
.\column_numbers.go:471:7:     from c.fill (dot of pointer) at .\column_numbers.go:472:11
.\column_numbers.go:471:7:     from &c.fill (address-of) at .\column_numbers.go:472:9
.\column_numbers.go:471:7:     from return &c.fill (return) at .\column_numbers.go:472:2
.\column_numbers.go:471:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:479:9: c.data[idx] escapes to heap:
.\column_numbers.go:479:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:479:9:     from c.data[idx] (spill) at .\column_numbers.go:479:9
.\column_numbers.go:479:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:479:9
.\column_numbers.go:477:4: int16(0) escapes to heap:
.\column_numbers.go:477:4:   flow: v = &{storage for int16(0)}:
.\column_numbers.go:477:4:     from int16(0) (spill) at .\column_numbers.go:477:4
.\column_numbers.go:477:4:     from v = int16(0) (assign) at .\column_numbers.go:477:4
.\column_numbers.go:476:7: c does not escape
.\column_numbers.go:477:4: int16(0) escapes to heap
.\column_numbers.go:479:9: c.data[idx] escapes to heap
.\column_numbers.go:485:7: c does not escape
.\column_numbers.go:493:7: c does not escape
.\column_numbers.go:501:7: c does not escape
.\column_numbers.go:509:7: c does not escape
.\column_numbers.go:509:37: index does not escape
.\column_numbers.go:509:59: predicate does not escape
.\column_numbers.go:511:15: func literal does not escape
.\column_numbers.go:517:7: c does not escape
.\column_numbers.go:517:35: index does not escape
.\column_numbers.go:517:57: predicate does not escape
.\column_numbers.go:519:15: func literal does not escape
.\column_numbers.go:525:7: c does not escape
.\column_numbers.go:525:36: index does not escape
.\column_numbers.go:525:58: predicate does not escape
.\column_numbers.go:527:15: func literal does not escape
.\column_numbers.go:542:9: &columnInt32{...} escapes to heap:
.\column_numbers.go:542:9:   flow: ~r0 = &{storage for &columnInt32{...}}:
.\column_numbers.go:542:9:     from &columnInt32{...} (spill) at .\column_numbers.go:542:9
.\column_numbers.go:542:9:     from &columnInt32{...} (interface-converted) at .\column_numbers.go:542:9
.\column_numbers.go:542:9:     from return &columnInt32{...} (return) at .\column_numbers.go:542:2
.\column_numbers.go:544:13: make([]int32, 0, 64) escapes to heap:
.\column_numbers.go:544:13:   flow: {storage for &columnInt32{...}} = &{storage for make([]int32, 0, 64)}:
.\column_numbers.go:544:13:     from make([]int32, 0, 64) (spill) at .\column_numbers.go:544:13
.\column_numbers.go:544:13:     from columnInt32{...} (struct literal element) at .\column_numbers.go:542:21
.\column_numbers.go:543:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:543:13:   flow: {storage for &columnInt32{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:543:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:543:13
.\column_numbers.go:543:13:     from columnInt32{...} (struct literal element) at .\column_numbers.go:542:21
.\column_numbers.go:542:9: &columnInt32{...} escapes to heap
.\column_numbers.go:543:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:544:13: make([]int32, 0, 64) escapes to heap
.\column_numbers.go:555:10: (*columnInt32).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:560:15: make([]int32, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:560:15:   flow: {heap} = &{storage for make([]int32, idx + 1, int(~R0))}:
.\column_numbers.go:560:15:     from make([]int32, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:560:15
.\column_numbers.go:549:7: c does not escape
.\column_numbers.go:560:15: make([]int32, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:583:5: value escapes to heap:
.\column_numbers.go:583:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:583:5:     from value (spill) at .\column_numbers.go:583:5
.\column_numbers.go:583:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:580:30
.\column_numbers.go:583:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:580:15
.\column_numbers.go:566:7: c does not escape
.\column_numbers.go:566:30: updates does not escape
.\column_numbers.go:583:5: value escapes to heap
.\column_numbers.go:590:7: c does not escape
.\column_numbers.go:590:42: items does not escape
.\column_numbers.go:596:7: c does not escape
.\column_numbers.go:601:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:601:7:   flow: ~r0 = c:
.\column_numbers.go:601:7:     from c.fill (dot of pointer) at .\column_numbers.go:602:11
.\column_numbers.go:601:7:     from &c.fill (address-of) at .\column_numbers.go:602:9
.\column_numbers.go:601:7:     from return &c.fill (return) at .\column_numbers.go:602:2
.\column_numbers.go:601:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:609:9: c.data[idx] escapes to heap:
.\column_numbers.go:609:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:609:9:     from c.data[idx] (spill) at .\column_numbers.go:609:9
.\column_numbers.go:609:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:609:9
.\column_numbers.go:607:4: int32(0) escapes to heap:
.\column_numbers.go:607:4:   flow: v = &{storage for int32(0)}:
.\column_numbers.go:607:4:     from int32(0) (spill) at .\column_numbers.go:607:4
.\column_numbers.go:607:4:     from v = int32(0) (assign) at .\column_numbers.go:607:4
.\column_numbers.go:606:7: c does not escape
.\column_numbers.go:607:4: int32(0) escapes to heap
.\column_numbers.go:609:9: c.data[idx] escapes to heap
.\column_numbers.go:615:7: c does not escape
.\column_numbers.go:623:7: c does not escape
.\column_numbers.go:631:7: c does not escape
.\column_numbers.go:639:7: c does not escape
.\column_numbers.go:639:37: index does not escape
.\column_numbers.go:639:59: predicate does not escape
.\column_numbers.go:641:15: func literal does not escape
.\column_numbers.go:647:7: c does not escape
.\column_numbers.go:647:35: index does not escape
.\column_numbers.go:647:57: predicate does not escape
.\column_numbers.go:649:15: func literal does not escape
.\column_numbers.go:655:7: c does not escape
.\column_numbers.go:655:36: index does not escape
.\column_numbers.go:655:58: predicate does not escape
.\column_numbers.go:657:15: func literal does not escape
.\column_numbers.go:672:9: &columnInt64{...} escapes to heap:
.\column_numbers.go:672:9:   flow: ~r0 = &{storage for &columnInt64{...}}:
.\column_numbers.go:672:9:     from &columnInt64{...} (spill) at .\column_numbers.go:672:9
.\column_numbers.go:672:9:     from &columnInt64{...} (interface-converted) at .\column_numbers.go:672:9
.\column_numbers.go:672:9:     from return &columnInt64{...} (return) at .\column_numbers.go:672:2
.\column_numbers.go:674:13: make([]int64, 0, 64) escapes to heap:
.\column_numbers.go:674:13:   flow: {storage for &columnInt64{...}} = &{storage for make([]int64, 0, 64)}:
.\column_numbers.go:674:13:     from make([]int64, 0, 64) (spill) at .\column_numbers.go:674:13
.\column_numbers.go:674:13:     from columnInt64{...} (struct literal element) at .\column_numbers.go:672:21
.\column_numbers.go:673:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:673:13:   flow: {storage for &columnInt64{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:673:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:673:13
.\column_numbers.go:673:13:     from columnInt64{...} (struct literal element) at .\column_numbers.go:672:21
.\column_numbers.go:672:9: &columnInt64{...} escapes to heap
.\column_numbers.go:673:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:674:13: make([]int64, 0, 64) escapes to heap
.\column_numbers.go:685:10: (*columnInt64).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:690:15: make([]int64, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:690:15:   flow: {heap} = &{storage for make([]int64, idx + 1, int(~R0))}:
.\column_numbers.go:690:15:     from make([]int64, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:690:15
.\column_numbers.go:679:7: c does not escape
.\column_numbers.go:690:15: make([]int64, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:713:5: value escapes to heap:
.\column_numbers.go:713:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:713:5:     from value (spill) at .\column_numbers.go:713:5
.\column_numbers.go:713:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:710:30
.\column_numbers.go:713:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:710:15
.\column_numbers.go:696:7: c does not escape
.\column_numbers.go:696:30: updates does not escape
.\column_numbers.go:713:5: value escapes to heap
.\column_numbers.go:720:7: c does not escape
.\column_numbers.go:720:42: items does not escape
.\column_numbers.go:726:7: c does not escape
.\column_numbers.go:731:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:731:7:   flow: ~r0 = c:
.\column_numbers.go:731:7:     from c.fill (dot of pointer) at .\column_numbers.go:732:11
.\column_numbers.go:731:7:     from &c.fill (address-of) at .\column_numbers.go:732:9
.\column_numbers.go:731:7:     from return &c.fill (return) at .\column_numbers.go:732:2
.\column_numbers.go:731:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:739:9: c.data[idx] escapes to heap:
.\column_numbers.go:739:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:739:9:     from c.data[idx] (spill) at .\column_numbers.go:739:9
.\column_numbers.go:739:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:739:9
.\column_numbers.go:737:4: int64(0) escapes to heap:
.\column_numbers.go:737:4:   flow: v = &{storage for int64(0)}:
.\column_numbers.go:737:4:     from int64(0) (spill) at .\column_numbers.go:737:4
.\column_numbers.go:737:4:     from v = int64(0) (assign) at .\column_numbers.go:737:4
.\column_numbers.go:736:7: c does not escape
.\column_numbers.go:737:4: int64(0) escapes to heap
.\column_numbers.go:739:9: c.data[idx] escapes to heap
.\column_numbers.go:745:7: c does not escape
.\column_numbers.go:753:7: c does not escape
.\column_numbers.go:761:7: c does not escape
.\column_numbers.go:769:7: c does not escape
.\column_numbers.go:769:37: index does not escape
.\column_numbers.go:769:59: predicate does not escape
.\column_numbers.go:771:15: func literal does not escape
.\column_numbers.go:777:7: c does not escape
.\column_numbers.go:777:35: index does not escape
.\column_numbers.go:777:57: predicate does not escape
.\column_numbers.go:779:15: func literal does not escape
.\column_numbers.go:785:7: c does not escape
.\column_numbers.go:785:36: index does not escape
.\column_numbers.go:785:58: predicate does not escape
.\column_numbers.go:787:15: func literal does not escape
.\column_numbers.go:802:9: &columnUint{...} escapes to heap:
.\column_numbers.go:802:9:   flow: ~r0 = &{storage for &columnUint{...}}:
.\column_numbers.go:802:9:     from &columnUint{...} (spill) at .\column_numbers.go:802:9
.\column_numbers.go:802:9:     from &columnUint{...} (interface-converted) at .\column_numbers.go:802:9
.\column_numbers.go:802:9:     from return &columnUint{...} (return) at .\column_numbers.go:802:2
.\column_numbers.go:804:13: make([]uint, 0, 64) escapes to heap:
.\column_numbers.go:804:13:   flow: {storage for &columnUint{...}} = &{storage for make([]uint, 0, 64)}:
.\column_numbers.go:804:13:     from make([]uint, 0, 64) (spill) at .\column_numbers.go:804:13
.\column_numbers.go:804:13:     from columnUint{...} (struct literal element) at .\column_numbers.go:802:20
.\column_numbers.go:803:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:803:13:   flow: {storage for &columnUint{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:803:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:803:13
.\column_numbers.go:803:13:     from columnUint{...} (struct literal element) at .\column_numbers.go:802:20
.\column_numbers.go:802:9: &columnUint{...} escapes to heap
.\column_numbers.go:803:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:804:13: make([]uint, 0, 64) escapes to heap
.\column_numbers.go:815:10: (*columnUint).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:820:15: make([]uint, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:820:15:   flow: {heap} = &{storage for make([]uint, idx + 1, int(~R0))}:
.\column_numbers.go:820:15:     from make([]uint, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:820:15
.\column_numbers.go:809:7: c does not escape
.\column_numbers.go:820:15: make([]uint, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:843:5: value escapes to heap:
.\column_numbers.go:843:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:843:5:     from value (spill) at .\column_numbers.go:843:5
.\column_numbers.go:843:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:840:30
.\column_numbers.go:843:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:840:15
.\column_numbers.go:826:7: c does not escape
.\column_numbers.go:826:29: updates does not escape
.\column_numbers.go:843:5: value escapes to heap
.\column_numbers.go:850:7: c does not escape
.\column_numbers.go:850:41: items does not escape
.\column_numbers.go:856:7: c does not escape
.\column_numbers.go:861:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:861:7:   flow: ~r0 = c:
.\column_numbers.go:861:7:     from c.fill (dot of pointer) at .\column_numbers.go:862:11
.\column_numbers.go:861:7:     from &c.fill (address-of) at .\column_numbers.go:862:9
.\column_numbers.go:861:7:     from return &c.fill (return) at .\column_numbers.go:862:2
.\column_numbers.go:861:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:869:9: c.data[idx] escapes to heap:
.\column_numbers.go:869:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:869:9:     from c.data[idx] (spill) at .\column_numbers.go:869:9
.\column_numbers.go:869:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:869:9
.\column_numbers.go:867:4: uint(0) escapes to heap:
.\column_numbers.go:867:4:   flow: v = &{storage for uint(0)}:
.\column_numbers.go:867:4:     from uint(0) (spill) at .\column_numbers.go:867:4
.\column_numbers.go:867:4:     from v = uint(0) (assign) at .\column_numbers.go:867:4
.\column_numbers.go:866:7: c does not escape
.\column_numbers.go:867:4: uint(0) escapes to heap
.\column_numbers.go:869:9: c.data[idx] escapes to heap
.\column_numbers.go:875:7: c does not escape
.\column_numbers.go:883:7: c does not escape
.\column_numbers.go:891:7: c does not escape
.\column_numbers.go:899:7: c does not escape
.\column_numbers.go:899:36: index does not escape
.\column_numbers.go:899:58: predicate does not escape
.\column_numbers.go:901:15: func literal does not escape
.\column_numbers.go:907:7: c does not escape
.\column_numbers.go:907:34: index does not escape
.\column_numbers.go:907:56: predicate does not escape
.\column_numbers.go:909:15: func literal does not escape
.\column_numbers.go:915:7: c does not escape
.\column_numbers.go:915:35: index does not escape
.\column_numbers.go:915:57: predicate does not escape
.\column_numbers.go:917:15: func literal does not escape
.\column_numbers.go:932:9: &columnUint16{...} escapes to heap:
.\column_numbers.go:932:9:   flow: ~r0 = &{storage for &columnUint16{...}}:
.\column_numbers.go:932:9:     from &columnUint16{...} (spill) at .\column_numbers.go:932:9
.\column_numbers.go:932:9:     from &columnUint16{...} (interface-converted) at .\column_numbers.go:932:9
.\column_numbers.go:932:9:     from return &columnUint16{...} (return) at .\column_numbers.go:932:2
.\column_numbers.go:934:13: make([]uint16, 0, 64) escapes to heap:
.\column_numbers.go:934:13:   flow: {storage for &columnUint16{...}} = &{storage for make([]uint16, 0, 64)}:
.\column_numbers.go:934:13:     from make([]uint16, 0, 64) (spill) at .\column_numbers.go:934:13
.\column_numbers.go:934:13:     from columnUint16{...} (struct literal element) at .\column_numbers.go:932:22
.\column_numbers.go:933:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:933:13:   flow: {storage for &columnUint16{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:933:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:933:13
.\column_numbers.go:933:13:     from columnUint16{...} (struct literal element) at .\column_numbers.go:932:22
.\column_numbers.go:932:9: &columnUint16{...} escapes to heap
.\column_numbers.go:933:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:934:13: make([]uint16, 0, 64) escapes to heap
.\column_numbers.go:945:10: (*columnUint16).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:950:15: make([]uint16, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:950:15:   flow: {heap} = &{storage for make([]uint16, idx + 1, int(~R0))}:
.\column_numbers.go:950:15:     from make([]uint16, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:950:15
.\column_numbers.go:939:7: c does not escape
.\column_numbers.go:950:15: make([]uint16, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:973:5: value escapes to heap:
.\column_numbers.go:973:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:973:5:     from value (spill) at .\column_numbers.go:973:5
.\column_numbers.go:973:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:970:30
.\column_numbers.go:973:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:970:15
.\column_numbers.go:956:7: c does not escape
.\column_numbers.go:956:31: updates does not escape
.\column_numbers.go:973:5: value escapes to heap
.\column_numbers.go:980:7: c does not escape
.\column_numbers.go:980:43: items does not escape
.\column_numbers.go:986:7: c does not escape
.\column_numbers.go:991:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:991:7:   flow: ~r0 = c:
.\column_numbers.go:991:7:     from c.fill (dot of pointer) at .\column_numbers.go:992:11
.\column_numbers.go:991:7:     from &c.fill (address-of) at .\column_numbers.go:992:9
.\column_numbers.go:991:7:     from return &c.fill (return) at .\column_numbers.go:992:2
.\column_numbers.go:991:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:999:9: c.data[idx] escapes to heap:
.\column_numbers.go:999:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:999:9:     from c.data[idx] (spill) at .\column_numbers.go:999:9
.\column_numbers.go:999:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:999:9
.\column_numbers.go:997:4: uint16(0) escapes to heap:
.\column_numbers.go:997:4:   flow: v = &{storage for uint16(0)}:
.\column_numbers.go:997:4:     from uint16(0) (spill) at .\column_numbers.go:997:4
.\column_numbers.go:997:4:     from v = uint16(0) (assign) at .\column_numbers.go:997:4
.\column_numbers.go:996:7: c does not escape
.\column_numbers.go:997:4: uint16(0) escapes to heap
.\column_numbers.go:999:9: c.data[idx] escapes to heap
.\column_numbers.go:1005:7: c does not escape
.\column_numbers.go:1013:7: c does not escape
.\column_numbers.go:1021:7: c does not escape
.\column_numbers.go:1029:7: c does not escape
.\column_numbers.go:1029:38: index does not escape
.\column_numbers.go:1029:60: predicate does not escape
.\column_numbers.go:1031:15: func literal does not escape
.\column_numbers.go:1037:7: c does not escape
.\column_numbers.go:1037:36: index does not escape
.\column_numbers.go:1037:58: predicate does not escape
.\column_numbers.go:1039:15: func literal does not escape
.\column_numbers.go:1045:7: c does not escape
.\column_numbers.go:1045:37: index does not escape
.\column_numbers.go:1045:59: predicate does not escape
.\column_numbers.go:1047:15: func literal does not escape
.\column_numbers.go:1062:9: &columnUint32{...} escapes to heap:
.\column_numbers.go:1062:9:   flow: ~r0 = &{storage for &columnUint32{...}}:
.\column_numbers.go:1062:9:     from &columnUint32{...} (spill) at .\column_numbers.go:1062:9
.\column_numbers.go:1062:9:     from &columnUint32{...} (interface-converted) at .\column_numbers.go:1062:9
.\column_numbers.go:1062:9:     from return &columnUint32{...} (return) at .\column_numbers.go:1062:2
.\column_numbers.go:1064:13: make([]uint32, 0, 64) escapes to heap:
.\column_numbers.go:1064:13:   flow: {storage for &columnUint32{...}} = &{storage for make([]uint32, 0, 64)}:
.\column_numbers.go:1064:13:     from make([]uint32, 0, 64) (spill) at .\column_numbers.go:1064:13
.\column_numbers.go:1064:13:     from columnUint32{...} (struct literal element) at .\column_numbers.go:1062:22
.\column_numbers.go:1063:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:1063:13:   flow: {storage for &columnUint32{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:1063:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:1063:13
.\column_numbers.go:1063:13:     from columnUint32{...} (struct literal element) at .\column_numbers.go:1062:22
.\column_numbers.go:1062:9: &columnUint32{...} escapes to heap
.\column_numbers.go:1063:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:1064:13: make([]uint32, 0, 64) escapes to heap
.\column_numbers.go:1075:10: (*columnUint32).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:1080:15: make([]uint32, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:1080:15:   flow: {heap} = &{storage for make([]uint32, idx + 1, int(~R0))}:
.\column_numbers.go:1080:15:     from make([]uint32, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:1080:15
.\column_numbers.go:1069:7: c does not escape
.\column_numbers.go:1080:15: make([]uint32, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:1103:5: value escapes to heap:
.\column_numbers.go:1103:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:1103:5:     from value (spill) at .\column_numbers.go:1103:5
.\column_numbers.go:1103:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:1100:30
.\column_numbers.go:1103:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:1100:15
.\column_numbers.go:1086:7: c does not escape
.\column_numbers.go:1086:31: updates does not escape
.\column_numbers.go:1103:5: value escapes to heap
.\column_numbers.go:1110:7: c does not escape
.\column_numbers.go:1110:43: items does not escape
.\column_numbers.go:1116:7: c does not escape
.\column_numbers.go:1121:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:1121:7:   flow: ~r0 = c:
.\column_numbers.go:1121:7:     from c.fill (dot of pointer) at .\column_numbers.go:1122:11
.\column_numbers.go:1121:7:     from &c.fill (address-of) at .\column_numbers.go:1122:9
.\column_numbers.go:1121:7:     from return &c.fill (return) at .\column_numbers.go:1122:2
.\column_numbers.go:1121:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:1129:9: c.data[idx] escapes to heap:
.\column_numbers.go:1129:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:1129:9:     from c.data[idx] (spill) at .\column_numbers.go:1129:9
.\column_numbers.go:1129:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:1129:9
.\column_numbers.go:1127:4: uint32(0) escapes to heap:
.\column_numbers.go:1127:4:   flow: v = &{storage for uint32(0)}:
.\column_numbers.go:1127:4:     from uint32(0) (spill) at .\column_numbers.go:1127:4
.\column_numbers.go:1127:4:     from v = uint32(0) (assign) at .\column_numbers.go:1127:4
.\column_numbers.go:1126:7: c does not escape
.\column_numbers.go:1127:4: uint32(0) escapes to heap
.\column_numbers.go:1129:9: c.data[idx] escapes to heap
.\column_numbers.go:1135:7: c does not escape
.\column_numbers.go:1143:7: c does not escape
.\column_numbers.go:1151:7: c does not escape
.\column_numbers.go:1159:7: c does not escape
.\column_numbers.go:1159:38: index does not escape
.\column_numbers.go:1159:60: predicate does not escape
.\column_numbers.go:1161:15: func literal does not escape
.\column_numbers.go:1167:7: c does not escape
.\column_numbers.go:1167:36: index does not escape
.\column_numbers.go:1167:58: predicate does not escape
.\column_numbers.go:1169:15: func literal does not escape
.\column_numbers.go:1175:7: c does not escape
.\column_numbers.go:1175:37: index does not escape
.\column_numbers.go:1175:59: predicate does not escape
.\column_numbers.go:1177:15: func literal does not escape
.\column_numbers.go:1192:9: &columnUint64{...} escapes to heap:
.\column_numbers.go:1192:9:   flow: ~r0 = &{storage for &columnUint64{...}}:
.\column_numbers.go:1192:9:     from &columnUint64{...} (spill) at .\column_numbers.go:1192:9
.\column_numbers.go:1192:9:     from &columnUint64{...} (interface-converted) at .\column_numbers.go:1192:9
.\column_numbers.go:1192:9:     from return &columnUint64{...} (return) at .\column_numbers.go:1192:2
.\column_numbers.go:1194:13: make([]uint64, 0, 64) escapes to heap:
.\column_numbers.go:1194:13:   flow: {storage for &columnUint64{...}} = &{storage for make([]uint64, 0, 64)}:
.\column_numbers.go:1194:13:     from make([]uint64, 0, 64) (spill) at .\column_numbers.go:1194:13
.\column_numbers.go:1194:13:     from columnUint64{...} (struct literal element) at .\column_numbers.go:1192:22
.\column_numbers.go:1193:13: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_numbers.go:1193:13:   flow: {storage for &columnUint64{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_numbers.go:1193:13:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_numbers.go:1193:13
.\column_numbers.go:1193:13:     from columnUint64{...} (struct literal element) at .\column_numbers.go:1192:22
.\column_numbers.go:1192:9: &columnUint64{...} escapes to heap
.\column_numbers.go:1193:13: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_numbers.go:1194:13: make([]uint64, 0, 64) escapes to heap
.\column_numbers.go:1205:10: (*columnUint64).Grow ignoring self-assignment in c.data = c.data[:idx + 1]
.\column_numbers.go:1210:15: make([]uint64, idx + 1, int(~R0)) escapes to heap:
.\column_numbers.go:1210:15:   flow: {heap} = &{storage for make([]uint64, idx + 1, int(~R0))}:
.\column_numbers.go:1210:15:     from make([]uint64, idx + 1, int(~R0)) (non-constant size) at .\column_numbers.go:1210:15
.\column_numbers.go:1199:7: c does not escape
.\column_numbers.go:1210:15: make([]uint64, idx + 1, int(~R0)) escapes to heap
.\column_numbers.go:1233:5: value escapes to heap:
.\column_numbers.go:1233:5:   flow: {heap} = &{storage for value}:
.\column_numbers.go:1233:5:     from value (spill) at .\column_numbers.go:1233:5
.\column_numbers.go:1233:5:     from commit.Update{...} (struct literal element) at .\column_numbers.go:1230:30
.\column_numbers.go:1233:5:     from updates[i] = commit.Update{...} (assign) at .\column_numbers.go:1230:15
.\column_numbers.go:1216:7: c does not escape
.\column_numbers.go:1216:31: updates does not escape
.\column_numbers.go:1233:5: value escapes to heap
.\column_numbers.go:1240:7: c does not escape
.\column_numbers.go:1240:43: items does not escape
.\column_numbers.go:1246:7: c does not escape
.\column_numbers.go:1251:7: parameter c leaks to ~r0 with derefs=0:
.\column_numbers.go:1251:7:   flow: ~r0 = c:
.\column_numbers.go:1251:7:     from c.fill (dot of pointer) at .\column_numbers.go:1252:11
.\column_numbers.go:1251:7:     from &c.fill (address-of) at .\column_numbers.go:1252:9
.\column_numbers.go:1251:7:     from return &c.fill (return) at .\column_numbers.go:1252:2
.\column_numbers.go:1251:7: leaking param: c to result ~r0 level=0
.\column_numbers.go:1259:9: c.data[idx] escapes to heap:
.\column_numbers.go:1259:9:   flow: v = &{storage for c.data[idx]}:
.\column_numbers.go:1259:9:     from c.data[idx] (spill) at .\column_numbers.go:1259:9
.\column_numbers.go:1259:9:     from v, ok = <N> (assign-pair) at .\column_numbers.go:1259:9
.\column_numbers.go:1257:4: uint64(0) escapes to heap:
.\column_numbers.go:1257:4:   flow: v = &{storage for uint64(0)}:
.\column_numbers.go:1257:4:     from uint64(0) (spill) at .\column_numbers.go:1257:4
.\column_numbers.go:1257:4:     from v = uint64(0) (assign) at .\column_numbers.go:1257:4
.\column_numbers.go:1256:7: c does not escape
.\column_numbers.go:1257:4: uint64(0) escapes to heap
.\column_numbers.go:1259:9: c.data[idx] escapes to heap
.\column_numbers.go:1265:7: c does not escape
.\column_numbers.go:1273:7: c does not escape
.\column_numbers.go:1281:7: c does not escape
.\column_numbers.go:1289:7: c does not escape
.\column_numbers.go:1289:38: index does not escape
.\column_numbers.go:1289:60: predicate does not escape
.\column_numbers.go:1291:15: func literal does not escape
.\column_numbers.go:1297:7: c does not escape
.\column_numbers.go:1297:36: index does not escape
.\column_numbers.go:1297:58: predicate does not escape
.\column_numbers.go:1299:15: func literal does not escape
.\column_numbers.go:1305:7: c does not escape
.\column_numbers.go:1305:37: index does not escape
.\column_numbers.go:1305:59: predicate does not escape
.\column_numbers.go:1307:15: func literal does not escape
.\column_strings.go:28:9: &columnEnum{...} escapes to heap:
.\column_strings.go:28:9:   flow: ~r0 = &{storage for &columnEnum{...}}:
.\column_strings.go:28:9:     from &columnEnum{...} (spill) at .\column_strings.go:28:9
.\column_strings.go:28:9:     from &columnEnum{...} (interface-converted) at .\column_strings.go:28:9
.\column_strings.go:28:9:     from return &columnEnum{...} (return) at .\column_strings.go:28:2
.\column_strings.go:32:14: make(map[string]uint32, 16) escapes to heap:
.\column_strings.go:32:14:   flow: {storage for &columnEnum{...}} = &{storage for make(map[string]uint32, 16)}:
.\column_strings.go:32:14:     from make(map[string]uint32, 16) (spill) at .\column_strings.go:32:14
.\column_strings.go:32:14:     from columnEnum{...} (struct literal element) at .\column_strings.go:28:20
.\column_strings.go:31:14: make([]byte, 0, 16 * 32) escapes to heap:
.\column_strings.go:31:14:   flow: {storage for &columnEnum{...}} = &{storage for make([]byte, 0, 16 * 32)}:
.\column_strings.go:31:14:     from make([]byte, 0, 16 * 32) (spill) at .\column_strings.go:31:14
.\column_strings.go:31:14:     from columnEnum{...} (struct literal element) at .\column_strings.go:28:20
.\column_strings.go:30:14: make([]uint32, 0, 64) escapes to heap:
.\column_strings.go:30:14:   flow: {storage for &columnEnum{...}} = &{storage for make([]uint32, 0, 64)}:
.\column_strings.go:30:14:     from make([]uint32, 0, 64) (spill) at .\column_strings.go:30:14
.\column_strings.go:30:14:     from columnEnum{...} (struct literal element) at .\column_strings.go:28:20
.\column_strings.go:29:14: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\column_strings.go:29:14:   flow: {storage for &columnEnum{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\column_strings.go:29:14:     from make(bitmap.Bitmap, 0, 4) (spill) at .\column_strings.go:29:14
.\column_strings.go:29:14:     from columnEnum{...} (struct literal element) at .\column_strings.go:28:20
.\column_strings.go:28:9: &columnEnum{...} escapes to heap
.\column_strings.go:29:14: make(bitmap.Bitmap, 0, 4) escapes to heap
.\column_strings.go:30:14: make([]uint32, 0, 64) escapes to heap
.\column_strings.go:31:14: make([]byte, 0, 16 * 32) escapes to heap
.\column_strings.go:32:14: make(map[string]uint32, 16) escapes to heap
.\column_strings.go:43:10: (*columnEnum).Grow ignoring self-assignment in c.locs = c.locs[:idx + 1]
.\column_strings.go:48:15: make([]uint32, idx + 1, int(~R0)) escapes to heap:
.\column_strings.go:48:15:   flow: {heap} = &{storage for make([]uint32, idx + 1, int(~R0))}:
.\column_strings.go:48:15:     from make([]uint32, idx + 1, int(~R0)) (non-constant size) at .\column_strings.go:48:15
.\column_strings.go:37:7: c does not escape
.\column_strings.go:48:15: make([]uint32, idx + 1, int(~R0)) escapes to heap
.\column_strings.go:180:28: b does not escape
.\column_strings.go:74:7: parameter c leaks to {heap} with derefs=1:
.\column_strings.go:74:7:   flow: {heap} = *c:
.\column_strings.go:74:7:     from c.data (dot of pointer) at .\column_strings.go:92:19
.\column_strings.go:74:7:     from append(c.data, head[:]...) (call parameter) at .\column_strings.go:92:17
.\column_strings.go:74:7:     from c.data = append(c.data, head[:]...) (assign) at .\column_strings.go:92:9
.\column_strings.go:74:32: parameter v leaks to {heap} with derefs=0:
.\column_strings.go:74:32:   flow: v = v:
.\column_strings.go:74:32:     from v := v (assign-pair) at .\column_strings.go:75:18
.\column_strings.go:74:32:   flow: strHeader = &v:
.\column_strings.go:74:32:     from &v (address-of) at .\column_strings.go:75:18
.\column_strings.go:74:32:     from strHeader := (*reflect.StringHeader)(unsafe.Pointer(&v)) (assign) at .\column_strings.go:75:18
.\column_strings.go:74:32:   flow: {heap} = *strHeader:
.\column_strings.go:74:32:     from strHeader.Data (reflect.Header.Data) at .\column_strings.go:75:18
.\column_strings.go:74:32:     from byteHeader.Data = strHeader.Data (assign) at .\column_strings.go:75:18
.\column_strings.go:74:7: leaking param content: c
.\column_strings.go:74:32: leaking param: v
.\column_strings.go:54:29: parameter updates leaks to {heap} with derefs=2:
.\column_strings.go:54:29:   flow: {temp} = updates:
.\column_strings.go:54:29:   flow: u = *{temp}:
.\column_strings.go:54:29:     from for loop (range-deref) at .\column_strings.go:55:14
.\column_strings.go:54:29:   flow: {heap} = *u:
.\column_strings.go:54:29:     from u.Value (dot) at .\column_strings.go:62:27
.\column_strings.go:54:29:     from u.Value.(string) (dot) at .\column_strings.go:62:33
.\column_strings.go:54:29:     from c.findOrAdd(u.Value.(string)) (call parameter) at .\column_strings.go:62:25
.\column_strings.go:54:7: parameter c leaks to {heap} with derefs=1:
.\column_strings.go:54:7:   flow: {heap} = *c:
.\column_strings.go:54:7:     from c.findOrAdd(u.Value.(string)) (call parameter) at .\column_strings.go:62:25
.\column_strings.go:54:7: leaking param content: c
.\column_strings.go:54:29: leaking param content: updates
.\column_strings.go:98:7: parameter c leaks to ~r1 with derefs=1:
.\column_strings.go:98:7:   flow: data = *c:
.\column_strings.go:98:7:     from c.data (dot of pointer) at .\column_strings.go:100:11
.\column_strings.go:98:7:     from c.data[at + 1:at + 1 + size] (slice) at .\column_strings.go:100:16
.\column_strings.go:98:7:     from data := c.data[at + 1:at + 1 + size] (assign) at .\column_strings.go:100:7
.\column_strings.go:98:7:   flow: b = &data:
.\column_strings.go:98:7:     from &data (address-of) at .\column_strings.go:101:18
.\column_strings.go:98:7:     from b := &data (assign-pair) at .\column_strings.go:101:17
.\column_strings.go:98:7:   flow: ~R0 = *b:
.\column_strings.go:98:7:     from *(*string)(unsafe.Pointer(b)) (indirection) at .\column_strings.go:101:17
.\column_strings.go:98:7:     from ~R0 = <N> (assign-pair) at .\column_strings.go:101:17
.\column_strings.go:98:7:   flow: ~r1 = ~R0:
.\column_strings.go:98:7:     from return string(~R0) (return) at .\column_strings.go:101:2
.\column_strings.go:98:7: leaking param: c to result ~r1 level=1
.\column_strings.go:105:7: c does not escape
.\column_strings.go:105:41: items does not escape
.\column_strings.go:119:7: parameter c leaks to v with derefs=1:
.\column_strings.go:119:7:   flow: c = c:
.\column_strings.go:119:7:     from c, at := c, c.locs[idx] (assign-pair) at .\column_strings.go:121:19
.\column_strings.go:119:7:   flow: data = *c:
.\column_strings.go:119:7:     from c.data (dot of pointer) at .\column_strings.go:121:19
.\column_strings.go:119:7:     from c.data[at + 1:at + 1 + size] (slice) at .\column_strings.go:121:19
.\column_strings.go:119:7:     from data := c.data[at + 1:at + 1 + size] (assign) at .\column_strings.go:121:19
.\column_strings.go:119:7:   flow: b = &data:
.\column_strings.go:119:7:     from &data (address-of) at .\column_strings.go:121:19
.\column_strings.go:119:7:     from b := &data (assign-pair) at .\column_strings.go:121:19
.\column_strings.go:119:7:   flow: ~R0 = *b:
.\column_strings.go:119:7:     from *(*string)(unsafe.Pointer(b)) (indirection) at .\column_strings.go:121:19
.\column_strings.go:119:7:     from ~R0 = <N> (assign-pair) at .\column_strings.go:121:19
.\column_strings.go:119:7:   flow: ~R0 = ~R0:
.\column_strings.go:119:7:     from ~R0 = <N> (assign-pair) at .\column_strings.go:121:19
.\column_strings.go:119:7:   flow: v = ~R0:
.\column_strings.go:119:7:     from v, ok = <N> (assign-pair) at .\column_strings.go:121:9
.\column_strings.go:119:7: leaking param: c to result v level=1
.\column_strings.go:115:2: .autotmp_4 escapes to heap:
.\column_strings.go:115:2:   flow: v = &{storage for .autotmp_4}:
.\column_strings.go:115:2:     from .autotmp_4 (spill) at .\column_strings.go:115:2
.\column_strings.go:115:2:     from return c.LoadString(idx) (return) at .\column_strings.go:115:2
.\column_strings.go:114:7: parameter c leaks to {storage for .autotmp_4} with derefs=1:
.\column_strings.go:114:7:   flow: .autotmp_4 = *c:
.\column_strings.go:114:7:     from c.LoadString(idx) (call parameter) at .\column_strings.go:115:21
.\column_strings.go:114:7:   flow: {storage for .autotmp_4} = .autotmp_4:
.\column_strings.go:114:7:     from .autotmp_4 (interface-converted) at .\column_strings.go:115:2
.\column_strings.go:114:7: leaking param content: c
.\column_strings.go:115:2: .autotmp_4 escapes to heap
.\column_strings.go:128:7: parameter c leaks to {heap} with derefs=1:
.\column_strings.go:128:7:   flow: c = c:
.\column_strings.go:128:7:     from c, at := c, at (assign-pair) at .\column_strings.go:145:37
.\column_strings.go:128:7:   flow: data = *c:
.\column_strings.go:128:7:     from c.data (dot of pointer) at .\column_strings.go:145:37
.\column_strings.go:128:7:     from c.data[at + 1:at + 1 + size] (slice) at .\column_strings.go:145:37
.\column_strings.go:128:7:     from data := c.data[at + 1:at + 1 + size] (assign) at .\column_strings.go:145:37
.\column_strings.go:128:7:   flow: b = &data:
.\column_strings.go:128:7:     from &data (address-of) at .\column_strings.go:145:37
.\column_strings.go:128:7:     from b := &data (assign-pair) at .\column_strings.go:145:37
.\column_strings.go:128:7:   flow: ~R0 = *b:
.\column_strings.go:128:7:     from *(*string)(unsafe.Pointer(b)) (indirection) at .\column_strings.go:145:37
.\column_strings.go:128:7:     from ~R0 = <N> (assign-pair) at .\column_strings.go:145:37
.\column_strings.go:128:7:   flow: ~R0 = ~R0:
.\column_strings.go:128:7:     from ~R0 = <N> (assign-pair) at .\column_strings.go:145:37
.\column_strings.go:128:7:   flow: {heap} = ~R0:
.\column_strings.go:128:7:     from predicate(string(~R0)) (call parameter) at .\column_strings.go:145:28
.\column_strings.go:128:7: leaking param content: c
.\column_strings.go:128:35: index does not escape
.\column_strings.go:128:57: predicate does not escape
.\column_strings.go:141:15: func literal does not escape
.\column_strings.go:157:7: c does not escape
.\column_strings.go:162:7: parameter c leaks to ~r0 with derefs=0:
.\column_strings.go:162:7:   flow: ~r0 = c:
.\column_strings.go:162:7:     from c.fill (dot of pointer) at .\column_strings.go:163:11
.\column_strings.go:162:7:     from &c.fill (address-of) at .\column_strings.go:163:9
.\column_strings.go:162:7:     from return &c.fill (return) at .\column_strings.go:163:2
.\column_strings.go:162:7: leaking param: c to result ~r0 level=0
.\column_strings.go:175:13: b does not escape
.\column_strings.go:217:14: parameter v leaks to {heap} with derefs=0:
.\column_strings.go:217:14:   flow: strHeader = &v:
.\column_strings.go:217:14:     from &v (address-of) at .\column_strings.go:218:54
.\column_strings.go:217:14:     from strHeader := (*reflect.StringHeader)(unsafe.Pointer(&v)) (assign) at .\column_strings.go:218:12
.\column_strings.go:217:14:   flow: {heap} = *strHeader:
.\column_strings.go:217:14:     from strHeader.Data (reflect.Header.Data) at .\column_strings.go:220:29
.\column_strings.go:217:14:     from byteHeader.Data = strHeader.Data (assign) at .\column_strings.go:220:18
.\column_strings.go:217:14: leaking param: v
.\column_strings.go:229:15: parameter b leaks to ~r1 with derefs=1:
.\column_strings.go:229:15:   flow: ~r1 = *b:
.\column_strings.go:229:15:     from *(*string)(unsafe.Pointer(b)) (indirection) at .\column_strings.go:230:9
.\column_strings.go:229:15:     from return *(*string)(unsafe.Pointer(b)) (return) at .\column_strings.go:230:2
.\column_strings.go:229:15: leaking param: b to result ~r1 level=1
.\txn.go:43:17: parameter txn leaks to {heap} with derefs=0:
.\txn.go:43:17:   flow: {heap} = txn:
.\txn.go:43:17:     from txn (interface-converted) at .\txn.go:44:10
.\txn.go:43:17:     from txns.Put(txn) (call parameter) at .\txn.go:44:10
.\txn.go:43:17: leaking param: txn
.\txn.go:105:25: parameter columns leaks to {heap} with derefs=1:
.\txn.go:105:25:   flow: {temp} = columns:
.\txn.go:105:25:   flow: columnName = *{temp}:
.\txn.go:105:25:     from for loop (range-deref) at .\txn.go:106:23
.\txn.go:105:25:   flow: {heap} = columnName:
.\txn.go:105:25:     from txn.columnAt(columnName) (call parameter) at .\txn.go:107:29
.\txn.go:105:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:105:7:   flow: {heap} = *txn:
.\txn.go:105:7:     from txn.columnAt(columnName) (call parameter) at .\txn.go:107:29
.\txn.go:105:7: parameter txn leaks to ~r1 with derefs=0:
.\txn.go:105:7:   flow: ~r1 = txn:
.\txn.go:105:7:     from return txn (return) at .\txn.go:113:2
.\txn.go:105:7: leaking param content: txn
.\txn.go:105:7: leaking param: txn to result ~r1 level=0
.\txn.go:105:25: leaking param content: columns
.\txn.go:108:48: dst does not escape
.\txn.go:108:53: src does not escape
.\txn.go:108:43: func literal does not escape
.\txn.go:117:23: parameter columns leaks to {heap} with derefs=1:
.\txn.go:117:23:   flow: {temp} = columns:
.\txn.go:117:23:   flow: columnName = *{temp}:
.\txn.go:117:23:     from for loop (range-deref) at .\txn.go:118:23
.\txn.go:117:23:   flow: {heap} = columnName:
.\txn.go:117:23:     from txn.columnAt(columnName) (call parameter) at .\txn.go:119:29
.\txn.go:117:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:117:7:   flow: {heap} = *txn:
.\txn.go:117:7:     from txn.columnAt(columnName) (call parameter) at .\txn.go:119:29
.\txn.go:117:7: parameter txn leaks to ~r1 with derefs=0:
.\txn.go:117:7:   flow: ~r1 = txn:
.\txn.go:117:7:     from return txn (return) at .\txn.go:125:2
.\txn.go:117:7: leaking param content: txn
.\txn.go:117:7: leaking param: txn to result ~r1 level=0
.\txn.go:117:23: leaking param content: columns
.\txn.go:120:48: dst does not escape
.\txn.go:120:53: src does not escape
.\txn.go:120:43: func literal does not escape
.\txn.go:130:27: parameter column leaks to {heap} with derefs=0:
.\txn.go:130:27:   flow: {heap} = column:
.\txn.go:130:27:     from txn.columnAt(column) (call parameter) at .\txn.go:131:23
.\txn.go:130:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:130:7:   flow: {heap} = *txn:
.\txn.go:130:7:     from txn.columnAt(column) (call parameter) at .\txn.go:131:23
.\txn.go:130:7: parameter txn leaks to ~r2 with derefs=0:
.\txn.go:130:7:   flow: ~r2 = txn:
.\txn.go:130:7:     from return txn (return) at .\txn.go:134:3
.\txn.go:130:7: leaking param content: txn
.\txn.go:130:7: leaking param: txn to result ~r2 level=0
.\txn.go:130:27: leaking param: column
.\txn.go:130:42: predicate does not escape
.\txn.go:137:31: index does not escape
.\txn.go:137:16: func literal does not escape
.\txn.go:138:16: func literal does not escape
.\txn.go:157:31: index escapes to heap:
.\txn.go:157:31:   flow: {heap} = &index:
.\txn.go:157:31:     from &index (address-of) at .\txn.go:158:36
.\txn.go:157:31:     from c.Column.(Numeric).FilterFloat64(&index, predicate) (call parameter) at .\txn.go:158:35
.\txn.go:150:42: parameter predicate leaks to {heap} with derefs=0:
.\txn.go:150:42:   flow: {heap} = predicate:
.\txn.go:150:42:     from c.Column.(Numeric).FilterFloat64(&index, predicate) (call parameter) at .\txn.go:158:35
.\txn.go:150:27: parameter column leaks to {heap} with derefs=0:
.\txn.go:150:27:   flow: {heap} = column:
.\txn.go:150:27:     from txn.columnAt(column) (call parameter) at .\txn.go:151:23
.\txn.go:150:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:150:7:   flow: {heap} = *txn:
.\txn.go:150:7:     from txn.columnAt(column) (call parameter) at .\txn.go:151:23
.\txn.go:150:7: parameter txn leaks to ~r2 with derefs=0:
.\txn.go:150:7:   flow: ~r2 = txn:
.\txn.go:150:7:     from return txn (return) at .\txn.go:154:3
.\txn.go:150:7: leaking param content: txn
.\txn.go:150:7: leaking param: txn to result ~r2 level=0
.\txn.go:150:27: leaking param: column
.\txn.go:150:42: leaking param: predicate
.\txn.go:157:31: moved to heap: index
.\txn.go:157:16: func literal does not escape
.\txn.go:172:31: index escapes to heap:
.\txn.go:172:31:   flow: {heap} = &index:
.\txn.go:172:31:     from &index (address-of) at .\txn.go:173:34
.\txn.go:172:31:     from c.Column.(Numeric).FilterInt64(&index, predicate) (call parameter) at .\txn.go:173:33
.\txn.go:165:40: parameter predicate leaks to {heap} with derefs=0:
.\txn.go:165:40:   flow: {heap} = predicate:
.\txn.go:165:40:     from c.Column.(Numeric).FilterInt64(&index, predicate) (call parameter) at .\txn.go:173:33
.\txn.go:165:25: parameter column leaks to {heap} with derefs=0:
.\txn.go:165:25:   flow: {heap} = column:
.\txn.go:165:25:     from txn.columnAt(column) (call parameter) at .\txn.go:166:23
.\txn.go:165:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:165:7:   flow: {heap} = *txn:
.\txn.go:165:7:     from txn.columnAt(column) (call parameter) at .\txn.go:166:23
.\txn.go:165:7: parameter txn leaks to ~r2 with derefs=0:
.\txn.go:165:7:   flow: ~r2 = txn:
.\txn.go:165:7:     from return txn (return) at .\txn.go:169:3
.\txn.go:165:7: leaking param content: txn
.\txn.go:165:7: leaking param: txn to result ~r2 level=0
.\txn.go:165:25: leaking param: column
.\txn.go:165:40: leaking param: predicate
.\txn.go:172:31: moved to heap: index
.\txn.go:172:16: func literal does not escape
.\txn.go:187:31: index escapes to heap:
.\txn.go:187:31:   flow: {heap} = &index:
.\txn.go:187:31:     from &index (address-of) at .\txn.go:188:35
.\txn.go:187:31:     from c.Column.(Numeric).FilterUint64(&index, predicate) (call parameter) at .\txn.go:188:34
.\txn.go:180:41: parameter predicate leaks to {heap} with derefs=0:
.\txn.go:180:41:   flow: {heap} = predicate:
.\txn.go:180:41:     from c.Column.(Numeric).FilterUint64(&index, predicate) (call parameter) at .\txn.go:188:34
.\txn.go:180:26: parameter column leaks to {heap} with derefs=0:
.\txn.go:180:26:   flow: {heap} = column:
.\txn.go:180:26:     from txn.columnAt(column) (call parameter) at .\txn.go:181:23
.\txn.go:180:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:180:7:   flow: {heap} = *txn:
.\txn.go:180:7:     from txn.columnAt(column) (call parameter) at .\txn.go:181:23
.\txn.go:180:7: parameter txn leaks to ~r2 with derefs=0:
.\txn.go:180:7:   flow: ~r2 = txn:
.\txn.go:180:7:     from return txn (return) at .\txn.go:184:3
.\txn.go:180:7: leaking param content: txn
.\txn.go:180:7: leaking param: txn to result ~r2 level=0
.\txn.go:180:26: leaking param: column
.\txn.go:180:41: leaking param: predicate
.\txn.go:187:31: moved to heap: index
.\txn.go:187:16: func literal does not escape
.\txn.go:202:31: index escapes to heap:
.\txn.go:202:31:   flow: {heap} = &index:
.\txn.go:202:31:     from &index (address-of) at .\txn.go:203:35
.\txn.go:202:31:     from c.Column.(Textual).FilterString(&index, predicate) (call parameter) at .\txn.go:203:34
.\txn.go:195:43: parameter predicate leaks to {heap} with derefs=0:
.\txn.go:195:43:   flow: {heap} = predicate:
.\txn.go:195:43:     from c.Column.(Textual).FilterString(&index, predicate) (call parameter) at .\txn.go:203:34
.\txn.go:195:28: parameter column leaks to {heap} with derefs=0:
.\txn.go:195:28:   flow: {heap} = column:
.\txn.go:195:28:     from txn.columnAt(column) (call parameter) at .\txn.go:196:23
.\txn.go:195:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:195:7:   flow: {heap} = *txn:
.\txn.go:195:7:     from txn.columnAt(column) (call parameter) at .\txn.go:196:23
.\txn.go:195:7: parameter txn leaks to ~r2 with derefs=0:
.\txn.go:195:7:   flow: ~r2 = txn:
.\txn.go:195:7:     from return txn (return) at .\txn.go:199:3
.\txn.go:195:7: leaking param content: txn
.\txn.go:195:7: leaking param: txn to result ~r2 level=0
.\txn.go:195:28: leaking param: column
.\txn.go:195:43: leaking param: predicate
.\txn.go:202:31: moved to heap: index
.\txn.go:202:16: func literal does not escape
.\txn.go:209:7: txn does not escape
.\txn.go:215:7: parameter txn leaks to ~r1 with derefs=0:
.\txn.go:215:7:   flow: ~r1 = txn:
.\txn.go:215:7:     from Selector{...} (struct literal element) at .\txn.go:220:17
.\txn.go:215:7:     from return Selector{...}, true (return) at .\txn.go:220:2
.\txn.go:215:7: leaking param: txn to result ~r1 level=0
.\txn.go:240:24: parameter object leaks to {heap} with derefs=1:
.\txn.go:240:24:   flow: {heap} = *object:
.\txn.go:240:24:     from txn.insert(object, 0) (call parameter) at .\txn.go:241:19
.\txn.go:240:7: parameter txn leaks to {heap} with derefs=1:
.\txn.go:240:7:   flow: {heap} = *txn:
.\txn.go:240:7:     from txn.insert(object, 0) (call parameter) at .\txn.go:241:19
.\txn.go:240:7: leaking param content: txn
.\txn.go:240:24: leaking param content: object
.\txn.go:280:7: parameter txn leaks to {heap} with derefs=0:
.\txn.go:280:7:   flow: {heap} = txn:
.\txn.go:280:7:     from Selector{...} (struct literal element) at .\txn.go:283:15
.\txn.go:280:7:     from fn(Selector{...}) (call parameter) at .\txn.go:283:6
.\txn.go:280:7: parameter txn leaks to {heap} with derefs=0:
.\txn.go:280:7:   flow: {heap} = txn:
.\txn.go:280:7:     from Selector{...} (struct literal element) at .\txn.go:283:15
.\txn.go:280:7:     from fn(Selector{...}) (call parameter) at .\txn.go:283:6
.\txn.go:280:7: leaking param: txn
.\txn.go:280:24: fn does not escape
.\txn.go:281:36: index does not escape
.\txn.go:281:16: func literal does not escape
.\txn.go:282:15: func literal does not escape
.\txn.go:294:7: parameter txn leaks to {heap} with derefs=0:
.\txn.go:294:7:   flow: {heap} = txn:
.\txn.go:294:7:     from Selector{...} (struct literal element) at .\txn.go:296:17
.\txn.go:294:7:     from fn(Selector{...}) (call parameter) at .\txn.go:296:8
.\txn.go:294:7: leaking param: txn
.\txn.go:294:26: fn does not escape
.\txn.go:295:18: func literal does not escape
.\txn.go:305:7: txn does not escape
.\txn.go:309:20: func literal does not escape
.\txn.go:347:7: parameter txn leaks to {heap} with derefs=2:
.\txn.go:347:7:   flow: {heap} = **txn:
.\txn.go:347:7:     from txn.reset() (call parameter) at .\txn.go:348:11
.\txn.go:347:7: leaking param content: txn
.\txn_cursor.go:60:31: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:60:31:   flow: {heap} = column:
.\txn_cursor.go:60:31:     from cur.txn.columnAt(column) (call parameter) at .\txn_cursor.go:62:26
.\txn_cursor.go:60:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:60:7:   flow: {heap} = **cur:
.\txn_cursor.go:60:7:     from cur.txn (dot of pointer) at .\txn_cursor.go:62:13
.\txn_cursor.go:60:7:     from cur.txn.columnAt(column) (call parameter) at .\txn_cursor.go:62:26
.\txn_cursor.go:60:7: leaking param content: cur
.\txn_cursor.go:60:31: leaking param: column
.\txn_cursor.go:70:30: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:70:30:   flow: {heap} = column:
.\txn_cursor.go:70:30:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:71:26
.\txn_cursor.go:70:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:70:7:   flow: {heap} = **cur:
.\txn_cursor.go:70:7:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:71:26
.\txn_cursor.go:70:7: leaking param content: cur
.\txn_cursor.go:70:30: leaking param: column
.\txn_cursor.go:78:31: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:78:31:   flow: {heap} = column:
.\txn_cursor.go:78:31:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:79:26
.\txn_cursor.go:78:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:78:7:   flow: {heap} = **cur:
.\txn_cursor.go:78:7:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:79:26
.\txn_cursor.go:78:7: leaking param content: cur
.\txn_cursor.go:78:31: leaking param: column
.\txn_cursor.go:86:30: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:86:30:   flow: {heap} = column:
.\txn_cursor.go:86:30:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:87:26
.\txn_cursor.go:86:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:86:7:   flow: {heap} = **cur:
.\txn_cursor.go:86:7:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:87:26
.\txn_cursor.go:86:7: leaking param content: cur
.\txn_cursor.go:86:30: leaking param: column
.\txn_cursor.go:94:28: parameter columnName leaks to {heap} with derefs=0:
.\txn_cursor.go:94:28:   flow: {heap} = columnName:
.\txn_cursor.go:94:28:     from cur.columnAt(columnName) (call parameter) at .\txn_cursor.go:95:26
.\txn_cursor.go:94:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:94:7:   flow: {heap} = **cur:
.\txn_cursor.go:94:7:     from cur.columnAt(columnName) (call parameter) at .\txn_cursor.go:95:26
.\txn_cursor.go:94:7: leaking param content: cur
.\txn_cursor.go:94:28: leaking param: columnName
.\txn_cursor.go:102:29: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:102:29:   flow: {heap} = column:
.\txn_cursor.go:102:29:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:103:26
.\txn_cursor.go:102:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:102:7:   flow: {heap} = **cur:
.\txn_cursor.go:102:7:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:103:26
.\txn_cursor.go:102:7: leaking param content: cur
.\txn_cursor.go:102:29: leaking param: column
.\txn_cursor.go:110:29: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:110:29:   flow: {heap} = column:
.\txn_cursor.go:110:29:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:111:26
.\txn_cursor.go:110:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:110:7:   flow: {heap} = **cur:
.\txn_cursor.go:110:7:     from cur.columnAt(column) (call parameter) at .\txn_cursor.go:111:26
.\txn_cursor.go:110:7: leaking param content: cur
.\txn_cursor.go:110:29: leaking param: column
.\txn_cursor.go:127:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:127:7:   flow: c = *cur:
.\txn_cursor.go:127:7:     from cur.column (dot of pointer) at .\txn_cursor.go:128:14
.\txn_cursor.go:127:7:     from c, idx := cur.column, cur.Selector.idx (assign-pair) at .\txn_cursor.go:128:27
.\txn_cursor.go:127:7:   flow: {heap} = *c:
.\txn_cursor.go:127:7:     from c.Column (dot of pointer) at .\txn_cursor.go:128:27
.\txn_cursor.go:127:7:     from c.Column.Value(idx) (call parameter) at .\txn_cursor.go:128:27
.\txn_cursor.go:127:7: leaking param content: cur
.\txn_cursor.go:133:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:133:7:   flow: c = *cur:
.\txn_cursor.go:133:7:     from cur.column (dot of pointer) at .\txn_cursor.go:134:14
.\txn_cursor.go:133:7:     from c, idx := cur.column, cur.Selector.idx (assign-pair) at .\txn_cursor.go:134:28
.\txn_cursor.go:133:7:   flow: column = *c:
.\txn_cursor.go:133:7:     from c.Column (dot of pointer) at .\txn_cursor.go:134:28
.\txn_cursor.go:133:7:     from c.Column.(Textual) (dot) at .\txn_cursor.go:134:28
.\txn_cursor.go:133:7:     from column, text = c.Column.(Textual) (assign-pair-dot-type) at .\txn_cursor.go:134:28
.\txn_cursor.go:133:7:   flow: {heap} = column:
.\txn_cursor.go:133:7:     from column.LoadString(idx) (call parameter) at .\txn_cursor.go:134:28
.\txn_cursor.go:133:7: leaking param content: cur
.\txn_cursor.go:139:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:139:7:   flow: c = *cur:
.\txn_cursor.go:139:7:     from cur.column (dot of pointer) at .\txn_cursor.go:140:14
.\txn_cursor.go:139:7:     from c, idx := cur.column, cur.Selector.idx (assign-pair) at .\txn_cursor.go:140:29
.\txn_cursor.go:139:7:   flow: n = *c:
.\txn_cursor.go:139:7:     from c.Column (dot of pointer) at .\txn_cursor.go:140:29
.\txn_cursor.go:139:7:     from c.Column.(Numeric) (dot) at .\txn_cursor.go:140:29
.\txn_cursor.go:139:7:     from n, contains = c.Column.(Numeric) (assign-pair-dot-type) at .\txn_cursor.go:140:29
.\txn_cursor.go:139:7:   flow: {heap} = n:
.\txn_cursor.go:139:7:     from n.LoadFloat64(idx) (call parameter) at .\txn_cursor.go:140:29
.\txn_cursor.go:139:7: leaking param content: cur
.\txn_cursor.go:151:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:151:7:   flow: c = *cur:
.\txn_cursor.go:151:7:     from cur.column (dot of pointer) at .\txn_cursor.go:152:14
.\txn_cursor.go:151:7:     from c, idx := cur.column, cur.Selector.idx (assign-pair) at .\txn_cursor.go:152:28
.\txn_cursor.go:151:7:   flow: n = *c:
.\txn_cursor.go:151:7:     from c.Column (dot of pointer) at .\txn_cursor.go:152:28
.\txn_cursor.go:151:7:     from c.Column.(Numeric) (dot) at .\txn_cursor.go:152:28
.\txn_cursor.go:151:7:     from n, contains = c.Column.(Numeric) (assign-pair-dot-type) at .\txn_cursor.go:152:28
.\txn_cursor.go:151:7:   flow: {heap} = n:
.\txn_cursor.go:151:7:     from n.LoadUint64(idx) (call parameter) at .\txn_cursor.go:152:28
.\txn_cursor.go:151:7: leaking param content: cur
.\txn_cursor.go:157:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:157:7:   flow: {heap} = **cur:
.\txn_cursor.go:157:7:     from cur.column (dot of pointer) at .\txn_cursor.go:158:12
.\txn_cursor.go:157:7:     from cur.column.Column (dot of pointer) at .\txn_cursor.go:158:19
.\txn_cursor.go:157:7:     from cur.column.Column.Contains(cur.Selector.idx) (call parameter) at .\txn_cursor.go:158:28
.\txn_cursor.go:157:7: leaking param content: cur
.\txn_cursor.go:183:24: parameter amount leaks to {heap} with derefs=0:
.\txn_cursor.go:183:24:   flow: {heap} = amount:
.\txn_cursor.go:183:24:     from commit.Update{...} (struct literal element) at .\txn_cursor.go:185:95
.\txn_cursor.go:183:24:     from append(cur.Selector.txn.updates[cur.update].Update, commit.Update{...}) (call parameter) at .\txn_cursor.go:185:45
.\txn_cursor.go:183:7: parameter cur leaks to {heap} with derefs=3:
.\txn_cursor.go:183:7:   flow: {heap} = ***cur:
.\txn_cursor.go:183:7:     from cur.updateChunk(cur.Selector.idx) (call parameter) at .\txn_cursor.go:184:17
.\txn_cursor.go:183:7: leaking param content: cur
.\txn_cursor.go:183:24: leaking param: amount
.\txn_cursor.go:205:41: parameter amount leaks to {heap} with derefs=0:
.\txn_cursor.go:205:41:   flow: {heap} = amount:
.\txn_cursor.go:205:41:     from commit.Update{...} (struct literal element) at .\txn_cursor.go:207:97
.\txn_cursor.go:205:41:     from append(cur.Selector.txn.updates[columnIndex].Update, commit.Update{...}) (call parameter) at .\txn_cursor.go:207:46
.\txn_cursor.go:205:26: parameter column leaks to {heap} with derefs=0:
.\txn_cursor.go:205:26:   flow: {heap} = column:
.\txn_cursor.go:205:26:     from cur.updateChunkAt(column, cur.Selector.idx) (call parameter) at .\txn_cursor.go:206:34
.\txn_cursor.go:205:7: parameter cur leaks to {heap} with derefs=2:
.\txn_cursor.go:205:7:   flow: {heap} = **cur:
.\txn_cursor.go:205:7:     from cur.updateChunkAt(column, cur.Selector.idx) (call parameter) at .\txn_cursor.go:206:34
.\txn_cursor.go:205:7: leaking param content: cur
.\txn_cursor.go:205:26: leaking param: column
.\txn_cursor.go:205:41: leaking param: amount
.\txn.go:20:10: &Txn{...} escapes to heap:
.\txn.go:20:10:   flow: ~r0 = &{storage for &Txn{...}}:
.\txn.go:20:10:     from &Txn{...} (spill) at .\txn.go:20:10
.\txn.go:20:10:     from &Txn{...} (interface-converted) at .\txn.go:20:10
.\txn.go:20:10:     from return &Txn{...} (return) at .\txn.go:20:3
.\txn.go:26:17: make([]columnCache, 0, 16) escapes to heap:
.\txn.go:26:17:   flow: {storage for &Txn{...}} = &{storage for make([]columnCache, 0, 16)}:
.\txn.go:26:17:     from make([]columnCache, 0, 16) (spill) at .\txn.go:26:17
.\txn.go:26:17:     from Txn{...} (struct literal element) at .\txn.go:20:14
.\txn.go:25:17: make([]commit.Updates, 0, 256) escapes to heap:
.\txn.go:25:17:   flow: {storage for &Txn{...}} = &{storage for make([]commit.Updates, 0, 256)}:
.\txn.go:25:17:     from make([]commit.Updates, 0, 256) (spill) at .\txn.go:25:17
.\txn.go:25:17:     from Txn{...} (struct literal element) at .\txn.go:20:14
.\txn.go:24:17: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\txn.go:24:17:   flow: {storage for &Txn{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\txn.go:24:17:     from make(bitmap.Bitmap, 0, 4) (spill) at .\txn.go:24:17
.\txn.go:24:17:     from Txn{...} (struct literal element) at .\txn.go:20:14
.\txn.go:23:17: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\txn.go:23:17:   flow: {storage for &Txn{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\txn.go:23:17:     from make(bitmap.Bitmap, 0, 4) (spill) at .\txn.go:23:17
.\txn.go:23:17:     from Txn{...} (struct literal element) at .\txn.go:20:14
.\txn.go:22:17: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\txn.go:22:17:   flow: {storage for &Txn{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\txn.go:22:17:     from make(bitmap.Bitmap, 0, 4) (spill) at .\txn.go:22:17
.\txn.go:22:17:     from Txn{...} (struct literal element) at .\txn.go:20:14
.\txn.go:21:17: make(bitmap.Bitmap, 0, 4) escapes to heap:
.\txn.go:21:17:   flow: {storage for &Txn{...}} = &{storage for make(bitmap.Bitmap, 0, 4)}:
.\txn.go:21:17:     from make(bitmap.Bitmap, 0, 4) (spill) at .\txn.go:21:17
.\txn.go:21:17:     from Txn{...} (struct literal element) at .\txn.go:20:14
.\txn.go:20:10: &Txn{...} escapes to heap
.\txn.go:21:17: make(bitmap.Bitmap, 0, 4) escapes to heap
.\txn.go:22:17: make(bitmap.Bitmap, 0, 4) escapes to heap
.\txn.go:23:17: make(bitmap.Bitmap, 0, 4) escapes to heap
.\txn.go:24:17: make(bitmap.Bitmap, 0, 4) escapes to heap
.\txn.go:25:17: make([]commit.Updates, 0, 256) escapes to heap
.\txn.go:26:17: make([]columnCache, 0, 16) escapes to heap
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Contains(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:41:21: parameter items leaks to {heap} with derefs=0:
.\column.go:41:21:   flow: {heap} = items:
.\column.go:41:21:     from .this.Delete(offset, items) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Delete(offset, items) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:41:21: leaking param: items
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Grow(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Index() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:40:9: parameter updates leaks to {heap} with derefs=0:
.\column.go:40:9:   flow: {heap} = updates:
.\column.go:40:9:     from .this.Update(updates) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Update(updates) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:40:9: leaking param: updates
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Value(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=1:
<autogenerated>:1:   flow: {heap} = *.this:
<autogenerated>:1:     from .this.Column (dot of pointer) at <autogenerated>:1
<autogenerated>:1:     from .this.Column.Contains(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param content: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Column (dot) at <autogenerated>:1
<autogenerated>:1:     from .this.Column.Contains(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=1:
<autogenerated>:1:   flow: {heap} = *.this:
<autogenerated>:1:     from .this.Column (dot of pointer) at <autogenerated>:1
<autogenerated>:1:     from .this.Column.Grow(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param content: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Column (dot) at <autogenerated>:1
<autogenerated>:1:     from .this.Column.Grow(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=1:
<autogenerated>:1:   flow: {heap} = *.this:
<autogenerated>:1:     from .this.Column (dot of pointer) at <autogenerated>:1
<autogenerated>:1:     from .this.Column.Index() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param content: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Column (dot) at <autogenerated>:1
<autogenerated>:1:     from .this.Column.Index() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: .this does not escape
.\txn_cursor.go:110:29: column does not escape
<autogenerated>:1: .this does not escape
.\txn_cursor.go:86:30: column does not escape
<autogenerated>:1: .this does not escape
.\txn_cursor.go:94:28: columnName does not escape
<autogenerated>:1: .this does not escape
.\txn_cursor.go:78:31: column does not escape
<autogenerated>:1: .this does not escape
.\txn_cursor.go:102:29: column does not escape
<autogenerated>:1: .this does not escape
.\txn_cursor.go:70:30: column does not escape
<autogenerated>:1: .this does not escape
.\txn_cursor.go:60:31: column does not escape
.\tnx_lock.go:68:12: index bounds check elided
.\tnx_lock.go:70:14: index bounds check elided
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Contains(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:41:21: parameter items leaks to {heap} with derefs=0:
.\column.go:41:21:   flow: {heap} = items:
.\column.go:41:21:     from .this.Delete(offset, items) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Delete(offset, items) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:41:21: leaking param: items
.\column.go:53:32: parameter .anon1 leaks to {heap} with derefs=0:
.\column.go:53:32:   flow: {heap} = .anon1:
.\column.go:53:32:     from .this.FilterFloat64(.anon0, .anon1) (call parameter) at <autogenerated>:1
.\column.go:53:16: parameter .anon0 leaks to {heap} with derefs=0:
.\column.go:53:16:   flow: {heap} = .anon0:
.\column.go:53:16:     from .this.FilterFloat64(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.FilterFloat64(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:53:16: leaking param: .anon0
.\column.go:53:32: leaking param: .anon1
.\column.go:55:30: parameter .anon1 leaks to {heap} with derefs=0:
.\column.go:55:30:   flow: {heap} = .anon1:
.\column.go:55:30:     from .this.FilterInt64(.anon0, .anon1) (call parameter) at <autogenerated>:1
.\column.go:55:14: parameter .anon0 leaks to {heap} with derefs=0:
.\column.go:55:14:   flow: {heap} = .anon0:
.\column.go:55:14:     from .this.FilterInt64(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.FilterInt64(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:55:14: leaking param: .anon0
.\column.go:55:30: leaking param: .anon1
.\column.go:54:31: parameter .anon1 leaks to {heap} with derefs=0:
.\column.go:54:31:   flow: {heap} = .anon1:
.\column.go:54:31:     from .this.FilterUint64(.anon0, .anon1) (call parameter) at <autogenerated>:1
.\column.go:54:15: parameter .anon0 leaks to {heap} with derefs=0:
.\column.go:54:15:   flow: {heap} = .anon0:
.\column.go:54:15:     from .this.FilterUint64(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.FilterUint64(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:54:15: leaking param: .anon0
.\column.go:54:31: leaking param: .anon1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Grow(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Index() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.LoadFloat64(.anon0) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.LoadInt64(.anon0) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.LoadUint64(.anon0) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:40:9: parameter updates leaks to {heap} with derefs=0:
.\column.go:40:9:   flow: {heap} = updates:
.\column.go:40:9:     from .this.Update(updates) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Update(updates) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:40:9: leaking param: updates
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Value(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Contains(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:41:21: parameter items leaks to {heap} with derefs=0:
.\column.go:41:21:   flow: {heap} = items:
.\column.go:41:21:     from .this.Delete(offset, items) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Delete(offset, items) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:41:21: leaking param: items
.\column.go:62:31: parameter .anon1 leaks to {heap} with derefs=0:
.\column.go:62:31:   flow: {heap} = .anon1:
.\column.go:62:31:     from .this.FilterString(.anon0, .anon1) (call parameter) at <autogenerated>:1
.\column.go:62:15: parameter .anon0 leaks to {heap} with derefs=0:
.\column.go:62:15:   flow: {heap} = .anon0:
.\column.go:62:15:     from .this.FilterString(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.FilterString(.anon0, .anon1) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:62:15: leaking param: .anon0
.\column.go:62:31: leaking param: .anon1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Grow(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Index() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.LoadString(.anon0) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:40:9: parameter updates leaks to {heap} with derefs=0:
.\column.go:40:9:   flow: {heap} = updates:
.\column.go:40:9:     from .this.Update(updates) (call parameter) at <autogenerated>:1
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Update(updates) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
.\column.go:40:9: leaking param: updates
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Value(idx) (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.Column() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
